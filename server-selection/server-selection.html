<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Server Selection - MongoDB Driver Specifications</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../driver-mantras.html">Mantras</a></li><li class="chapter-item expanded affix "><a href="../wireversion-featurelist/wireversion-featurelist.html">Wire Version Feature List</a></li><li class="chapter-item expanded affix "><li class="part-title">Specifications</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Serialization</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../BSON.html"><strong aria-hidden="true">1.1.</strong> BSON</a></li><li class="chapter-item expanded "><a href="../bson-objectid/objectid.html"><strong aria-hidden="true">1.2.</strong> ObjectId</a></li><li class="chapter-item expanded "><a href="../bson-decimal128/decimal128.html"><strong aria-hidden="true">1.3.</strong> Decimal128</a></li><li class="chapter-item expanded "><a href="../bson-binary-uuid/uuid.html"><strong aria-hidden="true">1.4.</strong> UUID</a></li><li class="chapter-item expanded "><a href="../dbref/dbref.html"><strong aria-hidden="true">1.5.</strong> DBRef</a></li><li class="chapter-item expanded "><a href="../extended-json/extended-json.html"><strong aria-hidden="true">1.6.</strong> Extended JSON</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Communication</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../message/OP_MSG.html"><strong aria-hidden="true">2.1.</strong> OP_MSG</a></li><li class="chapter-item expanded "><a href="../run-command/run-command.html"><strong aria-hidden="true">2.2.</strong> Command Execution</a></li><li class="chapter-item expanded "><a href="../connection-string/connection-string-spec.html"><strong aria-hidden="true">2.3.</strong> Connection String</a></li><li class="chapter-item expanded "><a href="../uri-options/uri-options.html"><strong aria-hidden="true">2.4.</strong> URI Options</a></li><li class="chapter-item expanded "><a href="../ocsp-support/ocsp-support.html"><strong aria-hidden="true">2.5.</strong> OCSP</a></li><li class="chapter-item expanded "><a href="../mongodb-handshake/handshake.html"><strong aria-hidden="true">2.6.</strong> Initial Handshake</a></li><li class="chapter-item expanded "><a href="../compression/OP_COMPRESSED.html"><strong aria-hidden="true">2.7.</strong> Wire Compression</a></li><li class="chapter-item expanded "><a href="../socks5-support/socks5.html"><strong aria-hidden="true">2.8.</strong> SOCKS5</a></li><li class="chapter-item expanded "><a href="../initial-dns-seedlist-discovery/initial-dns-seedlist-discovery.html"><strong aria-hidden="true">2.9.</strong> Initial DNS Seedlist Discovery</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Connectivity</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html"><strong aria-hidden="true">3.1.</strong> Server Discovery and Monitoring</a></li><li class="chapter-item expanded "><a href="../connection-monitoring-and-pooling/connection-monitoring-and-pooling.html"><strong aria-hidden="true">3.2.</strong> Connection Monitoring and Pooling</a></li><li class="chapter-item expanded "><a href="../load-balancers/load-balancers.html"><strong aria-hidden="true">3.3.</strong> Load Balancer Support</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Availability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server-discovery-and-monitoring/server-monitoring.html"><strong aria-hidden="true">4.1.</strong> Server Monitoring</a></li><li class="chapter-item expanded "><a href="../polling-srv-records-for-mongos-discovery/polling-srv-records-for-mongos-discovery.html"><strong aria-hidden="true">4.2.</strong> SRV Polling for mongos Discovery</a></li><li class="chapter-item expanded "><a href="../server-selection/server-selection.html" class="active"><strong aria-hidden="true">4.3.</strong> Server Selection</a></li><li class="chapter-item expanded "><a href="../max-staleness/max-staleness.html"><strong aria-hidden="true">4.4.</strong> Max Staleness</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Resilience</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Retryability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../retryable-reads/retryable-reads.html"><strong aria-hidden="true">5.1.1.</strong> Reads</a></li><li class="chapter-item expanded "><a href="../retryable-writes/retryable-writes.html"><strong aria-hidden="true">5.1.2.</strong> Writes</a></li></ol></li><li class="chapter-item expanded "><a href="../client-side-operations-timeout/client-side-operations-timeout.html"><strong aria-hidden="true">5.2.</strong> CSOT</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Consistency</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../sessions/driver-sessions.html"><strong aria-hidden="true">5.3.1.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="../causal-consistency/causal-consistency.html"><strong aria-hidden="true">5.3.2.</strong> Causal Consistency</a></li><li class="chapter-item expanded "><a href="../sessions/snapshot-sessions.html"><strong aria-hidden="true">5.3.3.</strong> Snapshot Reads</a></li><li class="chapter-item expanded "><a href="../transactions/transactions.html"><strong aria-hidden="true">5.3.4.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="../transactions-convenient-api/transactions-convenient-api.html"><strong aria-hidden="true">5.3.5.</strong> Convenient Transactions API</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Resource Management</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../enumerate-databases/enumerate-databases.html"><strong aria-hidden="true">6.1.1.</strong> Databases</a></li><li class="chapter-item expanded "><a href="../enumerate-collections/enumerate-collections.html"><strong aria-hidden="true">6.1.2.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../index-management/index-management.html"><strong aria-hidden="true">6.1.3.</strong> Indexes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Data Management</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../crud/crud.html"><strong aria-hidden="true">6.2.1.</strong> CRUD</a></li><li class="chapter-item expanded "><a href="../collation/collation.html"><strong aria-hidden="true">6.2.2.</strong> Collation</a></li><li class="chapter-item expanded "><a href="../server_write_commands/server_write_commands.html"><strong aria-hidden="true">6.2.3.</strong> Write Commands</a></li><li class="chapter-item expanded "><a href="../driver-bulk-update.html"><strong aria-hidden="true">6.2.4.</strong> Bulk API</a></li><li class="chapter-item expanded "><a href="../crud/bulk-write.html"><strong aria-hidden="true">6.2.5.</strong> Bulk Write</a></li><li class="chapter-item expanded "><a href="../read-write-concern/read-write-concern.html"><strong aria-hidden="true">6.2.6.</strong> R/W Concern</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Cursors</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../change-streams/change-streams.html"><strong aria-hidden="true">6.3.1.</strong> Change Streams</a></li><li class="chapter-item expanded "><a href="../find_getmore_killcursors_commands/find_getmore_killcursors_commands.html"><strong aria-hidden="true">6.3.2.</strong> find/getMore/killCursors</a></li></ol></li><li class="chapter-item expanded "><a href="../gridfs/gridfs-spec.html"><strong aria-hidden="true">6.4.</strong> GridFS</a></li><li class="chapter-item expanded "><a href="../versioned-api/versioned-api.html"><strong aria-hidden="true">6.5.</strong> Stable API</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.</strong> Security</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../client-side-encryption/client-side-encryption.html"><strong aria-hidden="true">6.6.1.</strong> Client Side Encryption</a></li><li class="chapter-item expanded "><a href="../bson-binary-encrypted/binary-encrypted.html"><strong aria-hidden="true">6.6.2.</strong> BSON Binary Subtype 6</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Observability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../command-logging-and-monitoring/command-logging-and-monitoring.html"><strong aria-hidden="true">7.1.</strong> Command Logging and Monitoring</a></li><li class="chapter-item expanded "><a href="../server-discovery-and-monitoring/server-discovery-and-monitoring-logging-and-monitoring.html"><strong aria-hidden="true">7.2.</strong> SDAM Logging and Monitoring</a></li><li class="chapter-item expanded "><a href="../logging/logging.html"><strong aria-hidden="true">7.3.</strong> Standardized Logging</a></li><li class="chapter-item expanded "><a href="../connection-monitoring-and-pooling/connection-monitoring-and-pooling.html"><strong aria-hidden="true">7.4.</strong> Connection Pool Logging</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Testability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unified-test-format/unified-test-format.html"><strong aria-hidden="true">8.1.</strong> Unified Test Format</a></li><li class="chapter-item expanded "><a href="../atlas-data-lake-testing/tests/index.html"><strong aria-hidden="true">8.2.</strong> Atlas Data Federation Testing</a></li><li class="chapter-item expanded "><a href="../benchmarking/benchmarking.html"><strong aria-hidden="true">8.3.</strong> Performance Benchmarking</a></li><li class="chapter-item expanded "><a href="../bson-corpus/bson-corpus.html"><strong aria-hidden="true">8.4.</strong> BSON Corpus</a></li><li class="chapter-item expanded "><a href="../connections-survive-step-down/tests/index.html"><strong aria-hidden="true">8.5.</strong> Replication Event Resilience</a></li><li class="chapter-item expanded "><a href="../faas-automated-testing/faas-automated-testing.html"><strong aria-hidden="true">8.6.</strong> FAAS Automated Testing</a></li><li class="chapter-item expanded "><a href="../serverless-testing/index.html"><strong aria-hidden="true">8.7.</strong> Atlas Serverless Testing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MongoDB Driver Specifications</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="server-selection"><a class="header" href="#server-selection">Server Selection</a></h1>
<ul>
<li>Status: Accepted</li>
<li>Minimum Server Version: 2.4</li>
</ul>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>MongoDB deployments may offer more than one server that can service an operation. This specification describes how
MongoDB drivers and mongos shall select a server for either read or write operations. It includes the definition of a
"read preference" document, configuration options, and algorithms for selecting a server for different deployment
topologies.</p>
<h2 id="meta"><a class="header" href="#meta">Meta</a></h2>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.</p>
<h2 id="motivation-for-change"><a class="header" href="#motivation-for-change">Motivation for Change</a></h2>
<p>This specification builds upon the prior "Driver Read Preference" specification, which had a number of omissions, flaws
or other deficiencies:</p>
<ol>
<li>Mandating features that implied monotonicity for situations where monotonicity is not guaranteed</li>
<li>Mandating features that are not supported by mongos</li>
<li>Neglecting to specify a single, standard way to calculate average latency times</li>
<li>Specifying complex command-helper rules</li>
<li>Omitting rules for applying read preferences to a single server or to select among multiple mongos servers</li>
<li>Omitting test cases for verification of spec compliance</li>
</ol>
<p>This revision addresses these problems as well as improving structure and specificity.</p>
<p>Additionally, it adds specifications for server selection more broadly:</p>
<ul>
<li>Selection of a server for write operations</li>
<li>Server selection retry and timeout</li>
</ul>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<h3 id="scope-and-general-requirements"><a class="header" href="#scope-and-general-requirements">Scope and general requirements</a></h3>
<p>This specification describes how MongoDB drivers and mongos select a server for read and write operations, including
commands, OP_QUERY, OP_INSERT, OP_UPDATE, and OP_DELETE. For read operations, it describes how drivers and mongos shall
interpret a read preference document.</p>
<p>This specification does not apply to OP_GET_MORE or OP_KILL_CURSORS operations on cursors, which need to go to the same
server that received an OP_QUERY and returned a cursor ID.</p>
<p>For operations that are part of a sharded transaction this specification only applies to the initial operation which
starts the transaction on a mongos. This specification does not apply to subsequent operations that are part of the
sharded transaction because all operations in a sharded transaction need to go to the same mongos server.</p>
<p>Drivers and mongos MUST conform to the semantics of this document, but SHOULD use language-appropriate data models or
variable names.</p>
<p>This specification does not apply to commands issued for server monitoring or authentication.</p>
<h3 id="terms"><a class="header" href="#terms">Terms</a></h3>
<p><strong>Available</strong></p>
<p>Describes a server that is believed to be reachable over the network and able to respond to requests. A server of type
Unknown or PossiblePrimary is not available; other types are available.</p>
<p><strong>Client</strong></p>
<p>Software that communicates with a MongoDB deployment. This includes both drivers and mongos.</p>
<p><strong>Candidate</strong></p>
<p>Describes servers in a deployment that enter the selection process, determined by the read preference <code>mode</code> parameter
and the servers' type. Depending on the <code>mode</code>, candidate servers might only include secondaries or might apply to all
servers in the deployment.</p>
<p><strong>Deployment</strong></p>
<p>One or more servers that collectively provide access to a single logical set of MongoDB databases.</p>
<p><strong>Command</strong></p>
<p>An OP_QUERY operation targeting the '$cmd' collection namespace.</p>
<p><strong>Direct connection</strong></p>
<p>A driver connection mode that sends all database operations to a single server without regard for type.</p>
<p><span id="eligible"></span></p>
<p><strong>Eligible</strong></p>
<p>Describes candidate servers that also meet the criteria specified by the <code>tag_sets</code> and <code>maxStalenessSeconds</code> read
preference parameters.</p>
<p><strong>Hedged Read</strong></p>
<p>A server mode in which the same query is dispatched in parallel to multiple replica set members.</p>
<p><strong>Immediate topology check</strong></p>
<p>For a multi-threaded or asynchronous client, this means waking all server monitors for an immediate check. For a
single-threaded client, this means a (blocking) scan of all servers.</p>
<p><strong>Latency window</strong></p>
<p>When choosing between several suitable servers, the latency window is the range of acceptable RTTs from the shortest RTT
to the shortest RTT plus the local threshold. E.g. if the shortest RTT is 15ms and the local threshold is 200ms, then
the latency window ranges from 15ms - 215ms.</p>
<p><strong>Local threshold</strong></p>
<p>The maximum acceptable difference in milliseconds between the shortest RTT and the longest RTT of servers suitable to be
selected.</p>
<p><strong>Mode</strong></p>
<p>One of several enumerated values used as part of a read preference, defining which server types are candidates for reads
and the semantics for choosing a specific one.</p>
<p><strong>Primary</strong></p>
<p>Describes a server of type RSPrimary.</p>
<p><strong>Query</strong></p>
<p>An OP_QUERY operation targeting a regular (non '$cmd') collection namespace.</p>
<p><strong>Read preference</strong></p>
<p>The parameters describing which servers in a deployment can receive read operations, including <code>mode</code>, <code>tag_sets</code>,
<code>maxStalenessSeconds</code>, and <code>hedge</code>.</p>
<p><strong>RS</strong></p>
<p>Abbreviation for "replica set".</p>
<p><strong>RTT</strong></p>
<p>Abbreviation for "round trip time".</p>
<p><strong>Round trip time</strong></p>
<p>The time in milliseconds to execute a <code>hello</code> or legacy hello command and receive a response for a given server. This
spec differentiates between the RTT of a single <code>hello</code> or legacy hello command and a server's <em>average</em> RTT over
several such commands.</p>
<p><strong>Secondary</strong></p>
<p>A server of type RSSecondary.</p>
<p><strong>Staleness</strong></p>
<p>A worst-case estimate of how far a secondary's replication lags behind the primary's last write.</p>
<p><strong>Server</strong></p>
<p>A mongod or mongos process.</p>
<p><strong>Server selection</strong></p>
<p>The process by which a server is chosen for a database operation out of all potential servers in a deployment.</p>
<p><strong>Server type</strong></p>
<p>An enumerated type indicating whether a server is up or down, whether it is a mongod or mongos, whether it belongs to a
replica set and, if so, what role it serves in the replica set. See the
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec for more
details.</p>
<p><strong>Suitable</strong></p>
<p>Describes a server that meets all specified criteria for a read or write operation.</p>
<p><strong>Tag</strong></p>
<p>A single key/value pair describing either (1) a user-specified characteristic of a replica set member or (2) a desired
characteristic for the target of a read operation. The key and value have no semantic meaning to the driver; they are
arbitrary user choices.</p>
<p><strong>Tag set</strong></p>
<p>A document of zero or more tags. Each member of a replica set can be configured with zero or one tag set.</p>
<p><strong>Tag set list</strong></p>
<p>A list of zero or more tag sets. A read preference might have a tag set list used for selecting servers.</p>
<p><strong>Topology</strong></p>
<p>The state of a deployment, including its type, which servers are members, and the server types of members.</p>
<p><strong>Topology type</strong></p>
<p>An enumerated type indicating the semantics for monitoring servers and selecting servers for database operations. See
the <a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec for
more details.</p>
<h3 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h3>
<ol>
<li>Unless they explicitly override these priorities, we assume our users prefer their applications to be, in order:
<ul>
<li>Predictable: the behavior of the application should not change based on the deployment type, whether single mongod,
replica set or sharded cluster.</li>
<li>Resilient: applications will adapt to topology changes, if possible, without raising errors or requiring manual
reconfiguration.</li>
<li>Low-latency: all else being equal, faster responses to queries and writes are preferable.</li>
</ul>
</li>
<li>Clients know the state of a deployment based on some form of ongoing monitoring, following the rules defined in the
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec.
<ul>
<li>They know which members are up or down, what their tag sets are, and their types.</li>
<li>They know average round trip times to each available member.</li>
<li>They detect reconfiguration and the addition or removal of members.</li>
</ul>
</li>
<li>The state of a deployment could change at any time, in between any network interaction.
<ul>
<li>Servers might or might not be reachable; they can change type at any time, whether due to partitions, elections, or
misconfiguration.</li>
<li>Data rollbacks could occur at any time.</li>
</ul>
</li>
</ol>
<h3 id="mongoclient-configuration"><a class="header" href="#mongoclient-configuration">MongoClient Configuration</a></h3>
<p>Selecting a server requires the following client-level configuration options:</p>
<h4 id="localthresholdms"><a class="header" href="#localthresholdms">localThresholdMS</a></h4>
<p>This defines the size of the latency window for selecting among multiple suitable servers. The default is 15
(milliseconds). It MUST be configurable at the client level. It MUST NOT be configurable at the level of a database
object, collection object, or at the level of an individual query.</p>
<p>In the prior read preference specification, <code>localThresholdMS</code> was called <code>secondaryAcceptableLatencyMS</code> by drivers.
Drivers MUST support the new name for consistency, but MAY continue to support the legacy name to avoid a
backward-breaking change.</p>
<p>mongos currently uses <code>localThreshold</code> and MAY continue to do so.</p>
<h4 id="serverselectiontimeoutms"><a class="header" href="#serverselectiontimeoutms">serverSelectionTimeoutMS</a></h4>
<p>This defines the maximum time to block for server selection before throwing an exception. The default is 30,000
(milliseconds). It MUST be configurable at the client level. It MUST NOT be configurable at the level of a database
object, collection object, or at the level of an individual query.</p>
<p>The actual timeout for server selection can be less than <code>serverSelectionTimeoutMS</code>. See <a href="#timeouts">Timeouts</a> for rules
to compute the exact value.</p>
<p>This default value was chosen to be sufficient for a typical server primary election to complete. As the server improves
the speed of elections, this number may be revised downward.</p>
<p>Users that can tolerate long delays for server selection when the topology is in flux can set this higher. Users that
want to "fail fast" when the topology is in flux can set this to a small number.</p>
<p>A serverSelectionTimeoutMS of zero MAY have special meaning in some drivers; zero's meaning is not defined in this spec,
but all drivers SHOULD document the meaning of zero.</p>
<h4 id="serverselectiontryonce"><a class="header" href="#serverselectiontryonce">serverSelectionTryOnce</a></h4>
<p>Single-threaded drivers MUST provide a "serverSelectionTryOnce" mode, in which the driver scans the topology exactly
once after server selection fails, then either selects a server or raises an error.</p>
<p>The serverSelectionTryOnce option MUST be true by default. If it is set false, then the driver repeatedly searches for
an appropriate server until the selection process times out (pausing
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html#minheartbeatfrequencyms">minHeartbeatFrequencyMS</a>
between attempts, as required by the
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec).</p>
<p>Users of single-threaded drivers MUST be able to control this mode in one or both of these ways:</p>
<ul>
<li>In code, pass true or false for an option called serverSelectionTryOnce, spelled idiomatically for the language, to
the MongoClient constructor.</li>
<li>Include "serverSelectionTryOnce=true" or "serverSelectionTryOnce=false" in the URI. The URI option is spelled the same
for all drivers.</li>
</ul>
<p>Conflicting usages of the URI option and the symbol is an error.</p>
<p>Multi-threaded drivers MUST NOT provide this mode. (See
<a href="#single-threaded-server-selection-implementation">single-threaded server selection implementation</a> and the rationale
for a <a href="#try-once-mode">"try once" mode</a>.)</p>
<h4 id="heartbeatfrequencyms"><a class="header" href="#heartbeatfrequencyms">heartbeatFrequencyMS</a></h4>
<p>This controls when topology updates are scheduled. See
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html#heartbeatfrequencyms">heartbeatFrequencyMS</a> in
the <a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec for
details.</p>
<h4 id="socketcheckintervalms"><a class="header" href="#socketcheckintervalms">socketCheckIntervalMS</a></h4>
<p>Only for single-threaded drivers.</p>
<p>The default socketCheckIntervalMS MUST be 5000 (5 seconds), and it MAY be configurable. If socket has been idle for at
least this long, it must be checked before being used again.</p>
<p>See <a href="#checking-an-idle-socket-after-socketcheckintervalms">checking an idle socket after socketCheckIntervalMS</a> and
<a href="#what-is-the-purpose-of-socketcheckintervalms">what is the purpose of socketCheckIntervalMS?</a>.</p>
<h4 id="idlewriteperiodms"><a class="header" href="#idlewriteperiodms">idleWritePeriodMS</a></h4>
<p>A constant, how often an idle primary writes a no-op to the oplog. See
<a href="../max-staleness/max-staleness.html#idlewriteperiodms">idleWritePeriodMS</a> in the
<a href="../max-staleness/max-staleness.html">Max Staleness</a> spec for details.</p>
<h4 id="smallestmaxstalenessseconds"><a class="header" href="#smallestmaxstalenessseconds">smallestMaxStalenessSeconds</a></h4>
<p>A constant, 90 seconds. See "Smallest allowed value for maxStalenessSeconds" in the Max Staleness Spec.</p>
<h4 id="serverselector"><a class="header" href="#serverselector">serverSelector</a></h4>
<p>Implementations MAY allow configuration of an optional, application-provided function that augments the server selection
rules. The function takes as a parameter a list of server descriptions representing the suitable servers for the read or
write operation, and returns a list of server descriptions that should still be considered suitable.</p>
<h3 id="read-preference"><a class="header" href="#read-preference">Read Preference</a></h3>
<p>A read preference determines which servers are considered suitable for read operations. Read preferences are interpreted
differently based on topology type. See topology-type-specific server selection rules for details.</p>
<p>When no servers are suitable, the selection might be retried or will eventually fail following the rules described in
the <a href="#rules-for-server-selection">Rules for server selection</a> section.</p>
<h4 id="components-of-a-read-preference"><a class="header" href="#components-of-a-read-preference">Components of a read preference</a></h4>
<p>A read preference consists of a <code>mode</code> and optional <code>tag_sets</code>, <code>maxStalenessSeconds</code>, and <code>hedge</code>. The <code>mode</code>
prioritizes between primaries and secondaries to produce either a single suitable server or a list of candidate servers.
If <code>tag_sets</code> and <code>maxStalenessSeconds</code> are set, they determine which candidate servers are eligible for selection. If
<code>hedge</code> is set, it configures how server hedged reads are used.</p>
<p>The default <code>mode</code> is 'primary'. The default <code>tag_sets</code> is a list with an empty tag set: <code>[{}]</code>. The default
<code>maxStalenessSeconds</code> is -1 or null, depending on the language. The default <code>hedge</code> is unset.</p>
<p>Each is explained in greater detail below.</p>
<h5 id="mode"><a class="header" href="#mode">mode</a></h5>
<p>For a deployment with topology type ReplicaSetWithPrimary or ReplicaSetNoPrimary, the <code>mode</code> parameter controls whether
primaries or secondaries are deemed suitable. Topology types Single and Sharded have different selection criteria and
are described elsewhere.</p>
<p>Clients MUST support these modes:</p>
<p><strong>primary</strong></p>
<p>Only an available primary is suitable.</p>
<p><strong>secondary</strong></p>
<p>All secondaries (and <em>only</em> secondaries) are candidates, but only <a href="#eligible">eligible</a> candidates (i.e. after applying
<code>tag_sets</code> and <code>maxStalenessSeconds</code>) are suitable.</p>
<p><strong>primaryPreferred</strong></p>
<p>If a primary is available, only the primary is suitable. Otherwise, all secondaries are candidates, but only eligible
secondaries are suitable.</p>
<p><strong>secondaryPreferred</strong></p>
<p>All secondaries are candidates. If there is at least one eligible secondary, only eligible secondaries are suitable.
Otherwise, when there are no eligible secondaries, the primary is suitable.</p>
<p><strong>nearest</strong></p>
<p>The primary and all secondaries are candidates, but only eligible candidates are suitable.</p>
<p><em>Note on other server types</em>: The
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec defines
several other server types that could appear in a replica set. Such types are never candidates, eligible or suitable.</p>
<p><span id="algorithm-for-filtering-by-staleness"></span></p>
<h5 id="maxstalenessseconds"><a class="header" href="#maxstalenessseconds">maxStalenessSeconds</a></h5>
<p>The maximum replication lag, in wall clock time, that a secondary can suffer and still be eligible.</p>
<p>The default is no maximum staleness.</p>
<p>A <code>maxStalenessSeconds</code> of -1 MUST mean "no maximum". Drivers are also free to use None, null, or other representations
of "no value" to represent "no max staleness".</p>
<p>Drivers MUST raise an error if <code>maxStalenessSeconds</code> is a positive number and the <code>mode</code> field is 'primary'.</p>
<p>A driver MUST raise an error if the TopologyType is ReplicaSetWithPrimary or ReplicaSetNoPrimary and either of these
conditions is false:</p>
<pre><code>maxStalenessSeconds * 1000 &gt;= heartbeatFrequencyMS + idleWritePeriodMS
maxStalenessSeconds &gt;= smallestMaxStalenessSeconds
</code></pre>
<p><code>heartbeatFrequencyMS</code> is defined in the
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec, and
<code>idleWritePeriodMS</code> is defined to be 10 seconds in the <a href="../max-staleness/max-staleness.html">Max Staleness</a> spec.</p>
<p>See "Smallest allowed value for maxStalenessSeconds" in the Max Staleness Spec.</p>
<p>mongos MUST reject a read with <code>maxStalenessSeconds</code> provided and a <code>mode</code> of 'primary'.</p>
<p>mongos MUST reject a read with <code>maxStalenessSeconds</code> that is not a positive integer.</p>
<p>mongos MUST reject a read if <code>maxStalenessSeconds</code> is less than smallestMaxStalenessSeconds, with error code 160
(SERVER-24421).</p>
<p>During server selection, drivers (but not mongos) with <code>minWireVersion</code> &lt; 5 MUST raise an error if
<code>maxStalenessSeconds</code> is a positive number, and any available server's <code>maxWireVersion</code> is less than 5.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>After filtering servers according to <code>mode</code>, and before filtering with <code>tag_sets</code>, eligibility MUST be determined from
<code>maxStalenessSeconds</code> as follows:</p>
<ul>
<li>
<p>If <code>maxStalenessSeconds</code> is not a positive number, then all servers are eligible.</p>
</li>
<li>
<p>Otherwise, calculate staleness. Non-secondary servers (including Mongos servers) have zero staleness. If TopologyType
is ReplicaSetWithPrimary, a secondary's staleness is calculated using its ServerDescription "S" and the primary's
ServerDescription "P":</p>
<pre><code>(S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate) + heartbeatFrequencyMS
</code></pre>
<p>(All datetime units are in milliseconds.)</p>
<p>If TopologyType is ReplicaSetNoPrimary, a secondary's staleness is calculated using its ServerDescription "S" and the
ServerDescription of the secondary with the greatest lastWriteDate, "SMax":</p>
<pre><code>SMax.lastWriteDate - S.lastWriteDate + heartbeatFrequencyMS
</code></pre>
<p>Servers with staleness less than or equal to <code>maxStalenessSeconds</code> are eligible.</p>
</li>
</ul>
<p>See the Max Staleness Spec for overall description and justification of this feature.</p>
<p><span id="algorithm-for-filtering-by-tag_sets"></span></p>
<h5 id="tag_sets"><a class="header" href="#tag_sets">tag_sets</a></h5>
<p>The read preference <code>tag_sets</code> parameter is an ordered list of tag sets used to restrict the eligibility of servers,
such as for data center awareness.</p>
<p>Clients MUST raise an error if a non-empty tag set is given in <code>tag_sets</code> and the <code>mode</code> field is 'primary'.</p>
<p>A read preference tag set (<code>T</code>) matches a server tag set (<code>S</code>) – or equivalently a server tag set (<code>S</code>) matches a read
preference tag set (<code>T</code>) — if <code>T</code> is a subset of <code>S</code> (i.e. <code>T ⊆ S</code>).</p>
<p>For example, the read preference tag set "{ dc: 'ny', rack: '2' }" matches a secondary server with tag set "{ dc: 'ny',
rack: '2', size: 'large' }".</p>
<p>A tag set that is an empty document matches any server, because the empty tag set is a subset of any tag set. This means
the default <code>tag_sets</code> parameter (<code>[{}]</code>) matches all servers.</p>
<p>Tag sets are applied after filtering servers by <code>mode</code> and <code>maxStalenessSeconds</code>, and before selecting one server within
the latency window.</p>
<p>Eligibility MUST be determined from <code>tag_sets</code> as follows:</p>
<ul>
<li>If the <code>tag_sets</code> list is empty then all candidate servers are eligible servers. (Note, the default of <code>[{}]</code> means an
empty list probably won't often be seen, but if the client does not forbid an empty list, this rule MUST be
implemented to handle that case.)</li>
<li>If the <code>tag_sets</code> list is not empty, then tag sets are tried in order until a tag set matches at least one candidate
server. All candidate servers matching that tag set are eligible servers. Subsequent tag sets in the list are ignored.</li>
<li>If the <code>tag_sets</code> list is not empty and no tag set in the list matches any candidate server, no servers are eligible
servers.</li>
</ul>
<h5 id="hedge"><a class="header" href="#hedge">hedge</a></h5>
<p>The read preference <code>hedge</code> parameter is a document that configures how the server will perform hedged reads. It
consists of the following keys:</p>
<ul>
<li><code>enabled</code>: Enables or disables hedging</li>
</ul>
<p>Hedged reads are automatically enabled in MongoDB 4.4+ when using a <code>nearest</code> read preference. To explicitly enable
hedging, the <code>hedge</code> document must be passed. An empty document uses server defaults to control hedging, but the
<code>enabled</code> key may be set to <code>true</code> or <code>false</code> to explicitly enable or disable hedged reads.</p>
<p>Drivers MAY allow users to specify an empty hedge document if they accept documents for read preference options. Any
driver that exposes a builder API for read preference objects MUST NOT allow an empty <code>hedge</code> document to be
constructed. In this case, the user MUST specify a value for <code>enabled</code>, which MUST default to <code>true</code>. If the user does
not call a <code>hedge</code> API method, drivers MUST NOT send a <code>hedge</code> option to the server.</p>
<h4 id="read-preference-configuration"><a class="header" href="#read-preference-configuration">Read preference configuration</a></h4>
<p>Drivers MUST allow users to configure a default read preference on a <code>MongoClient</code> object. Drivers MAY allow users to
configure a default read preference on a <code>Database</code> or <code>Collection</code> object.</p>
<p>A read preference MAY be specified as an object, document or individual <code>mode</code>, <code>tag_sets</code>, and <code>maxStalenessSeconds</code>
parameters, depending on what is most idiomatic for the language.</p>
<p>If more than one object has a default read preference, the default of the most specific object takes precedence. I.e.
<code>Collection</code> is preferred over <code>Database</code>, which is preferred over <code>MongoClient</code>.</p>
<p>Drivers MAY allow users to set a read preference on queries on a per-operation basis similar to how <code>hint</code> or
<code>batchSize</code> are set. E.g., in Python:</p>
<pre><code class="language-python">db.collection.find({}, read_preference=ReadPreference.SECONDARY)
db.collection.find(
    {},
    read_preference=ReadPreference.NEAREST,
    tag_sets=[{'dc': 'ny'}],
    maxStalenessSeconds=120,
    hedge={'enabled': true})
</code></pre>
<p><span id="passing-read-preference-to-mongos"></span></p>
<h4 id="passing-read-preference-to-mongos-and-load-balancers"><a class="header" href="#passing-read-preference-to-mongos-and-load-balancers">Passing read preference to mongos and load balancers</a></h4>
<p>If a server of type Mongos or LoadBalancer is selected for a read operation, the read preference is passed to the
selected mongos through the use of <code>$readPreference</code> (as a
<a href="../message/OP_MSG.html#global-command-arguments">Global Command Argument</a> for OP_MSG or a query modifier for OP_QUERY)
and, for OP_QUERY only, the <code>SecondaryOk</code> wire protocol flag, according to the following rules.</p>
<h5 id="for-op_msg"><a class="header" href="#for-op_msg">For OP_MSG:</a></h5>
<ul>
<li>For mode 'primary', drivers MUST NOT set <code>$readPreference</code></li>
<li>For all other read preference modes (i.e. 'secondary', 'primaryPreferred', ...), drivers MUST set <code>$readPreference</code></li>
</ul>
<h5 id="for-op_query"><a class="header" href="#for-op_query">For OP_QUERY:</a></h5>
<p>If the read preference contains <strong>only</strong> a <code>mode</code> parameter and the mode is 'primary' or 'secondaryPreferred', for
maximum backwards compatibility with older versions of mongos, drivers MUST only use the value of the <code>SecondaryOk</code> wire
protocol flag (i.e. set or unset) to indicate the desired read preference and MUST NOT use a <code>$readPreference</code> query
modifier.</p>
<p>Therefore, when sending queries to a mongos or load balancer, the following rules apply:</p>
<ul>
<li>For mode 'primary', drivers MUST NOT set the <code>SecondaryOk</code> wire protocol flag and MUST NOT use <code>$readPreference</code></li>
<li>For mode 'secondary', drivers MUST set the <code>SecondaryOk</code> wire protocol flag and MUST also use <code>$readPreference</code></li>
<li>For mode 'primaryPreferred', drivers MUST set the <code>SecondaryOk</code> wire protocol flag and MUST also use <code>$readPreference</code></li>
<li>For mode 'secondaryPreferred', drivers MUST set the <code>SecondaryOk</code> wire protocol flag. If the read preference contains
a non-empty <code>tag_sets</code> parameter, <code>maxStalenessSeconds</code> is a positive integer, or the <code>hedge</code> parameter is non-empty,
drivers MUST use <code>$readPreference</code>; otherwise, drivers MUST NOT use <code>$readPreference</code></li>
<li>For mode 'nearest', drivers MUST set the <code>SecondaryOk</code> wire protocol flag and MUST also use <code>$readPreference</code></li>
</ul>
<p>The <code>$readPreference</code> query modifier sends the read preference as part of the query. The read preference fields
<code>tag_sets</code> is represented in a <code>$readPreference</code> document using the field name <code>tags</code>.</p>
<p>When sending a read operation via OP_QUERY and any <code>$</code> modifier is used, including the <code>$readPreference</code> modifier, the
query MUST be provided using the <code>$query</code> modifier like so:</p>
<pre><code class="language-javascript">{
    $query: {
        field1: 'query_value',
        field2: 'another_query_value'
    },
    $readPreference: {
        mode: 'secondary',
        tags: [ { 'dc': 'ny' } ],
        maxStalenessSeconds: 120,
        hedge: { enabled: true }
    }
}
</code></pre>
<h5 id="document-structure"><a class="header" href="#document-structure">Document structure</a></h5>
<p>A valid <code>$readPreference</code> document for mongos or load balancer has the following requirements:</p>
<ol>
<li>
<p>The <code>mode</code> field MUST be present exactly once with the mode represented in camel case:</p>
<ul>
<li>'primary'</li>
<li>'secondary'</li>
<li>'primaryPreferred'</li>
<li>'secondaryPreferred'</li>
<li>'nearest'</li>
</ul>
</li>
<li>
<p>If the <code>mode</code> field is "primary", the <code>tags</code>, <code>maxStalenessSeconds</code>, and <code>hedge</code> fields MUST be absent.</p>
<p>Otherwise, for other <code>mode</code> values, the <code>tags</code> field MUST either be absent or be present exactly once and have an
array value containing at least one document. It MUST contain only documents, no other type.</p>
<p>The <code>maxStalenessSeconds</code> field MUST be either be absent or be present exactly once with an integer value.</p>
<p>The <code>hedge</code> field MUST be either absent or be a document.</p>
</li>
</ol>
<p>Mongos or service receiving a query with <code>$readPreference</code> SHOULD validate the <code>mode</code>, <code>tags</code>, <code>maxStalenessSeconds</code>,
and <code>hedge</code> fields according to rules 1 and 2 above, but SHOULD ignore unrecognized fields for forward-compatibility
rather than throwing an error.</p>
<h4 id="use-of-read-preferences-with-commands"><a class="header" href="#use-of-read-preferences-with-commands">Use of read preferences with commands</a></h4>
<p>Because some commands are used for writes, deployment-changes or other state-changing side-effects, the use of read
preference by a driver depends on the command and how it is invoked:</p>
<ol>
<li>
<p>Write commands: <code>insert</code>, <code>update</code>, <code>delete</code>, <code>findAndModify</code></p>
<p>Write commands are considered write operations and MUST follow the corresponding
<a href="#rules-for-server-selection">Rules for server selection</a> for each topology type.</p>
</li>
<li>
<p>Generic command method: typically <code>command</code> or <code>runCommand</code></p>
<p>The generic command method MUST act as a read operation for the purposes of server selection.</p>
<p>The generic command method has a default read preference of <code>mode</code> 'primary'. The generic command method MUST ignore
any default read preference from client, database or collection configuration. The generic command method SHOULD
allow an optional read preference argument.</p>
<p>If an explicit read preference argument is provided as part of the generic command method call, it MUST be used for
server selection, regardless of the name of the command. It is up to the user to use an appropriate read preference,
e.g. not calling <code>renameCollection</code> with a <code>mode</code> of 'secondary'.</p>
<p>N.B.: "used for server selection" does not supersede rules for server selection on "Standalone" topologies, which
ignore any requested read preference.</p>
</li>
<li>
<p>Command-specific helper: methods that wrap database commands, like <code>count</code>, <code>distinct</code>, <code>listCollections</code> or
<code>renameCollection</code>.</p>
<p>Command-specific helpers MUST act as read operations for the purposes of server selection, with read preference rules
defined by the following three categories of commands:</p>
<ul>
<li>
<p>"must-use-primary": these commands have state-modifying effects and will only succeed on a primary. An example is
<code>renameCollection</code>.</p>
<p>These command-specific helpers MUST use a read preference <code>mode</code> of 'primary', MUST NOT take a read preference
argument and MUST ignore any default read preference from client, database or collection configuration. Languages
with dynamic argument lists MUST throw an error if a read preference is provided as an argument.</p>
<p>Clients SHOULD rely on the server to return a "not writable primary" or other error if the command is
"must-use-primary". Clients MAY raise an exception before sending the command if the topology type is Single and
the server type is not "Standalone", "RSPrimary" or "Mongos", but the identification of the set of
'must-use-primary' commands is out of scope for this specification.</p>
</li>
<li>
<p>"should-use-primary": these commands are intended to be run on a primary, but would succeed -- albeit with possibly
stale data -- when run against a secondary. An example is <code>listCollections</code>.</p>
<p>These command-specific helpers MUST use a read preference <code>mode</code> of 'primary', MUST NOT take a read preference
argument and MUST ignore any default read preference from client, database or collection configuration. Languages
with dynamic argument lists MUST throw an error if a read preference is provided as an argument.</p>
<p>Clients MUST NOT raise an exception if the topology type is Single.</p>
</li>
<li>
<p>"may-use-secondary": these commands run against primaries or secondaries, according to users' read preferences.
They are sometimes called "query-like" commands.</p>
<p>The current list of "may-use-secondary" commands includes:</p>
<ul>
<li>aggregate without a write stage (e.g. <code>$out</code>, <code>$merge</code>)</li>
<li>collStats</li>
<li>count</li>
<li>dbStats</li>
<li>distinct</li>
<li>find</li>
<li>geoNear</li>
<li>geoSearch</li>
<li>group</li>
<li>mapReduce where the <code>out</code> option is <code>{ inline: 1 }</code></li>
<li>parallelCollectionScan</li>
</ul>
<p>Associated command-specific helpers SHOULD take a read preference argument and otherwise MUST use the default read
preference from client, database, or collection configuration.</p>
<p>For pre-5.0 servers, an aggregate command is "must-use-primary" if its pipeline contains a write stage (e.g.
<code>$out</code>, <code>$merge</code>); otherwise, it is "may-use-secondary". For 5.0+ servers, secondaries can execute an aggregate
command with a write stage and all aggregate commands are "may-use-secondary". This is discussed in more detail in
<a href="../crud/crud.html#read-preferences-and-server-selection">Read preferences and server selection</a> in the CRUD spec.</p>
<p>If a client provides a specific helper for inline mapReduce, then it is "may-use-secondary" and the <em>regular</em>
mapReduce helper is "must-use-primary". Otherwise, the mapReduce helper is "may-use-secondary" and it is the user's
responsibility to specify <code>{inline: 1}</code> when running mapReduce on a secondary.</p>
</li>
</ul>
<p>New command-specific helpers implemented in the future will be considered "must-use-primary", "should-use-primary" or
"may-use-secondary" according to the specifications for those future commands. Command helper specifications SHOULD
use those terms for clarity.</p>
</li>
</ol>
<h3 id="rules-for-server-selection"><a class="header" href="#rules-for-server-selection">Rules for server selection</a></h3>
<p>Server selection is a process which takes an operation type (read or write), a ClusterDescription, and optionally a read
preference and, on success, returns a ServerDescription for an operation of the given type.</p>
<p>Server selection varies depending on whether a client is multi-threaded/asynchronous or single-threaded because a
single-threaded client cannot rely on the topology state being updated in the background.</p>
<h4 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h4>
<p>Multi-threaded drivers and single-threaded drivers with <code>serverSelectionTryOnce</code> set to false MUST enforce a timeout for
the server selection process. The timeout MUST be computed as described in
<a href="../client-side-operations-timeout/client-side-operations-timeout.html#server-selection">Client Side Operations Timeout: Server Selection</a>.</p>
<h4 id="multi-threaded-or-asynchronous-server-selection"><a class="header" href="#multi-threaded-or-asynchronous-server-selection">Multi-threaded or asynchronous server selection</a></h4>
<p>A driver that uses multi-threaded or asynchronous monitoring MUST unblock waiting operations as soon as server selection
completes, even if not all servers have been checked by a monitor. Put differently, the client MUST NOT block server
selection while waiting for server discovery to finish.</p>
<p>For example, if the client is discovering a replica set and the application attempts a read operation with mode
'primaryPreferred', the operation MUST proceed immediately if a suitable secondary is found, rather than blocking until
the client has checked all members and possibly discovered a primary.</p>
<p>The number of threads allowed to wait for server selection SHOULD be either (a) the same as the number of threads
allowed to wait for a connection from a pool; or (b) governed by a global or client-wide limit on number of waiting
threads, depending on how resource limits are implemented by a driver.</p>
<h5 id="operationcount"><a class="header" href="#operationcount">operationCount</a></h5>
<p>Multi-threaded or async drivers MUST keep track of the number of operations that a given server is currently executing
(the server's <code>operationCount</code>). This value MUST be incremented once a server is selected for an operation and MUST be
decremented once that operation has completed, regardless of its outcome. Where this value is stored is left as a
implementation detail of the driver; some example locations include the <code>Server</code> type that also owns the connection pool
for the server (if there exists such a type in the driver's implementation) or on the pool itself. Incrementing or
decrementing a server's <code>operationCount</code> MUST NOT wake up any threads that are waiting for a topology update as part of
server selection. See
<a href="#operationcount-based-selection-within-the-latency-window-multi-threaded-or-async">operationCount-based selection within the latency window (multi-threaded or async)</a>
for the rationale behind the way this value is used.</p>
<h5 id="server-selection-algorithm"><a class="header" href="#server-selection-algorithm">Server Selection Algorithm</a></h5>
<p>For multi-threaded clients, the server selection algorithm is as follows:</p>
<ol>
<li>Record the server selection start time and log a
<a href="#server-selection-started-message">"Server selection started" message</a>.</li>
<li>If the topology wire version is invalid, raise an error and log a
<a href="#server-selection-failed-message">"Server selection failed" message</a>.</li>
<li>Find suitable servers by topology type and operation type. If a list of deprioritized servers is provided, and the
topology is a sharded cluster, these servers should be selected only if there are no other suitable servers. The
server selection algorithm MUST ignore the deprioritized servers if the topology is not a sharded cluster.</li>
<li>Filter the suitable servers by calling the optional, application-provided server selector.</li>
<li>If there are any suitable servers, filter them according to
<a href="#filtering-suitable-servers-based-on-the-latency-window">Filtering suitable servers based on the latency window</a>
and continue to the next step; otherwise, log a
<a href="#waiting-for-suitable-server-to-become-available-message">"Waiting for suitable server to become available" message</a>
if one has not already been logged for this operation, and goto Step #9.</li>
<li>Choose two servers at random from the set of suitable servers in the latency window. If there is only 1 server in
the latency window, just select that server and goto Step #8.</li>
<li>Of the two randomly chosen servers, select the one with the lower <code>operationCount</code>. If both servers have the same
<code>operationCount</code>, select arbitrarily between the two of them.</li>
<li>Increment the <code>operationCount</code> of the selected server and return it. Log a
<a href="#server-selection-succeeded-message">"Server selection succeeded" message</a>. Do not go onto later steps.</li>
<li>Request an immediate topology check, then block the server selection thread until the topology changes or until the
server selection timeout has elapsed</li>
<li>If server selection has timed out, raise a <a href="#server-selection-errors">server selection error</a> and log a
<a href="#server-selection-failed-message">"Server selection failed" message</a>.</li>
<li>Goto Step #2</li>
</ol>
<h4 id="single-threaded-server-selection"><a class="header" href="#single-threaded-server-selection">Single-threaded server selection</a></h4>
<p>Single-threaded drivers do not monitor the topology in the background. Instead, they MUST periodically update the
topology during server selection as described below.</p>
<p>When <code>serverSelectionTryOnce</code> is true, server selection timeouts have no effect; a single immediate topology check will
be done if the topology starts stale or if the first selection attempt fails.</p>
<p>When <code>serverSelectionTryOnce</code> is false, then the server selection loops until a server is successfully selected or until
the selection timeout is exceeded.</p>
<p>Therefore, for single-threaded clients, the server selection algorithm is as follows:</p>
<ol>
<li>Record the server selection start time and log a
<a href="#server-selection-started-message">"Server selection started" message</a>.</li>
<li>Record the maximum time as start time plus the computed timeout</li>
<li>If the topology has not been scanned in <code>heartbeatFrequencyMS</code> milliseconds, mark the topology stale</li>
<li>If the topology is stale, proceed as follows:
<ul>
<li>record the target scan time as last scan time plus <code>minHeartBeatFrequencyMS</code></li>
<li>if <a href="#serverselectiontryonce">serverSelectionTryOnce</a> is false and the target scan time would exceed the maximum
time, raise a <a href="#server-selection-errors">server selection error</a> and log a
<a href="#server-selection-failed-message">"Server selection failed" message</a>.</li>
<li>if the current time is less than the target scan time, sleep until the target scan time</li>
<li>do a blocking immediate topology check (which must also update the last scan time and mark the topology as no
longer stale)</li>
</ul>
</li>
<li>If the topology wire version is invalid, raise an error and log a
<a href="#server-selection-failed-message">"Server selection failed" message</a>.</li>
<li>Find suitable servers by topology type and operation type. If a list of deprioritized servers is provided, and the
topology is a sharded cluster, these servers should be selected only if there are no other suitable servers. The
server selection algorithm MUST ignore the deprioritized servers if the topology is not a sharded cluster.</li>
<li>Filter the suitable servers by calling the optional, application-provided server selector.</li>
<li>If there are any suitable servers, filter them according to
<a href="#filtering-suitable-servers-based-on-the-latency-window">Filtering suitable servers based on the latency window</a>
and return one at random from the filtered servers, and log a
<a href="#server-selection-succeeded-message">"Server selection succeeded" message</a>.; otherwise, mark the topology stale and
continue to step #9.</li>
<li>If <a href="#serverselectiontryonce">serverSelectionTryOnce</a> is true and the last scan time is newer than the selection
start time, raise a <a href="#server-selection-errors">server selection error</a> and log a
<a href="#server-selection-failed-message">"Server selection failed" message</a>; otherwise, log a
<a href="#waiting-for-suitable-server-to-become-available-message">"Waiting for suitable server to become available" message</a>
if one has not already been logged for this operation, and goto Step #4</li>
<li>If the current time exceeds the maximum time, raise a <a href="#server-selection-errors">server selection error</a> and log a
<a href="#server-selection-failed-message">"Server selection failed" message</a>.</li>
<li>Goto Step #4</li>
</ol>
<p>Before using a socket to the selected server, drivers MUST check whether the socket has been used in
<a href="#socketcheckintervalms">socketCheckIntervalMS</a> milliseconds. If the socket has been idle for longer, the driver MUST
update the ServerDescription for the selected server. After updating, if the server is no longer suitable, the driver
MUST repeat the server selection algorithm and select a new server.</p>
<p>Because single-threaded selection can do a blocking immediate check, the server selection timeout is not a hard
deadline. The actual maximum server selection time for any given request can vary from the timeout minus
<code>minHeartbeatFrequencyMS</code> to the timeout plus the time required for a blocking scan.</p>
<p>Single-threaded drivers MUST document that when <code>serverSelectionTryOne</code> is true, selection may take up to the time
required for a blocking scan, and when <code>serverSelectionTryOne</code> is false, selection may take up to the timeout plus the
time required for a blocking scan.</p>
<h4 id="topology-type-unknown"><a class="header" href="#topology-type-unknown">Topology type: Unknown</a></h4>
<p>When a deployment has topology type "Unknown", no servers are suitable for read or write operations.</p>
<h4 id="topology-type-single"><a class="header" href="#topology-type-single">Topology type: Single</a></h4>
<p>A deployment of topology type Single contains only a single server of any type. Topology type Single signifies a direct
connection intended to receive all read and write operations.</p>
<p>Therefore, read preference is ignored during server selection with topology type Single. The single server is always
suitable for reads if it is available. Depending on server type, the read preference is communicated to the server
differently:</p>
<ul>
<li>Type Mongos: the read preference is sent to the server using the rules for
<a href="#passing-read-preference-to-mongos-and-load-balancers">Passing read preference to mongos and load balancers</a>.</li>
<li>Type Standalone: clients MUST NOT send the read preference to the server</li>
<li>For all other types, using OP_QUERY: clients MUST always set the <code>SecondaryOk</code> wire protocol flag on reads to ensure
that any server type can handle the request.</li>
<li>For all other types, using OP_MSG: If no read preference is configured by the application, or if the application read
preference is Primary, then $readPreference MUST be set to <code>{ "mode": "primaryPreferred" }</code> to ensure that any server
type can handle the request. If the application read preference is set otherwise, $readPreference MUST be set
following <a href="#document-structure">Document structure</a>.</li>
</ul>
<p>The single server is always suitable for write operations if it is available.</p>
<h4 id="topology-type-loadbalanced"><a class="header" href="#topology-type-loadbalanced">Topology type: LoadBalanced</a></h4>
<p>During command construction, drivers MUST add a $readPreference field to the command when required by
<a href="#passing-read-preference-to-mongos-and-load-balancers">Passing read preference to mongos and load balancers</a>; see the
<a href="../load-balancers/load-balancers.html#server-selection">Load Balancer Specification</a> for details.</p>
<h4 id="topology-types-replicasetwithprimary-or-replicasetnoprimary"><a class="header" href="#topology-types-replicasetwithprimary-or-replicasetnoprimary">Topology types: ReplicaSetWithPrimary or ReplicaSetNoPrimary</a></h4>
<p>A deployment with topology type ReplicaSetWithPrimary or ReplicaSetNoPrimary can have a mix of server types: RSPrimary
(only in ReplicaSetWithPrimary), RSSecondary, RSArbiter, RSOther, RSGhost, Unknown or PossiblePrimary.</p>
<h5 id="read-operations"><a class="header" href="#read-operations">Read operations</a></h5>
<p>For the purpose of selecting a server for read operations, the same rules apply to both ReplicaSetWithPrimary and
ReplicaSetNoPrimary.</p>
<p>To select from the topology a server that matches the user's Read Preference:</p>
<p>If <code>mode</code> is 'primary', select the primary server.</p>
<p>If <code>mode</code> is 'secondary' or 'nearest':</p>
<blockquote>
<ol>
<li>Select all secondaries if <code>mode</code> is 'secondary', or all secondaries and the primary if <code>mode</code> is 'nearest'.</li>
<li>From these, filter out servers staler than <code>maxStalenessSeconds</code> if it is a positive number.</li>
<li>From the remaining servers, select servers matching the <code>tag_sets</code>.</li>
<li>From these, select one server within the latency window.</li>
</ol>
</blockquote>
<p>(See <a href="#algorithm-for-filtering-by-staleness">algorithm for filtering by staleness</a>,
<a href="#algorithm-for-filtering-by-tag_sets">algorithm for filtering by tag_sets</a>, and
<a href="#filtering-suitable-servers-based-on-the-latency-window">filtering suitable servers based on the latency window</a> for
details on each step, and
<a href="#why-is-maxstalenessseconds-applied-before-tag_sets">why is maxStalenessSeconds applied before tag_sets?</a>.)</p>
<p>If <code>mode</code> is 'secondaryPreferred', attempt the selection algorithm with <code>mode</code> 'secondary' and the user's
<code>maxStalenessSeconds</code> and <code>tag_sets</code>. If no server matches, select the primary.</p>
<p>If <code>mode</code> is 'primaryPreferred', select the primary if it is known, otherwise attempt the selection algorithm with
<code>mode</code> 'secondary' and the user's <code>maxStalenessSeconds</code> and <code>tag_sets</code>.</p>
<p>For all read preferences modes except 'primary', clients MUST set the <code>SecondaryOk</code> wire protocol flag (OP_QUERY) or
<code>$readPreference</code> global command argument (OP_MSG) to ensure that any suitable server can handle the request. If the
read preference mode is 'primary', clients MUST NOT set the <code>SecondaryOk</code> wire protocol flag (OP_QUERY) or
<code>$readPreference</code> global command argument (OP_MSG).</p>
<h5 id="write-operations"><a class="header" href="#write-operations">Write operations</a></h5>
<p>If the topology type is ReplicaSetWithPrimary, only an available primary is suitable for write operations.</p>
<p>If the topology type is ReplicaSetNoPrimary, no servers are suitable for write operations.</p>
<h4 id="topology-type-sharded"><a class="header" href="#topology-type-sharded">Topology type: Sharded</a></h4>
<p>A deployment of topology type Sharded contains one or more servers of type Mongos or Unknown.</p>
<p>For read operations, all servers of type Mongos are suitable; the <code>mode</code>, <code>tag_sets</code>, and <code>maxStalenessSeconds</code> read
preference parameters are ignored for selecting a server, but are passed through to mongos. See
<a href="#passing-read-preference-to-mongos-and-load-balancers">Passing read preference to mongos and load balancers</a>.</p>
<p>For write operations, all servers of type Mongos are suitable.</p>
<p>If more than one mongos is suitable, drivers MUST select a suitable server within the latency window (see
<a href="#filtering-suitable-servers-based-on-the-latency-window">Filtering suitable servers based on the latency window</a>).</p>
<h3 id="round-trip-times-and-the-latency-window"><a class="header" href="#round-trip-times-and-the-latency-window">Round Trip Times and the Latency Window</a></h3>
<h4 id="calculation-of-average-round-trip-times"><a class="header" href="#calculation-of-average-round-trip-times">Calculation of Average Round Trip Times</a></h4>
<p>For every available server, clients MUST track the average RTT of server monitoring <code>hello</code> or legacy hello commands.</p>
<p>An Unknown server has no average RTT. When a server becomes unavailable, its average RTT MUST be cleared. Clients MAY
implement this idiomatically (e.g nil, -1, etc.).</p>
<p>When there is no average RTT for a server, the average RTT MUST be set equal to the first RTT measurement (i.e. the
first <code>hello</code> or legacy hello command after the server becomes available).</p>
<p>After the first measurement, average RTT MUST be computed using an exponentially-weighted moving average formula, with a
weighting factor (<code>alpha</code>) of 0.2. If the prior average is denoted <code>old_rtt</code>, then the new average (<code>new_rtt</code>) is
computed from a new RTT measurement (<code>x</code>) using the following formula:</p>
<pre><code class="language-javascript">    alpha = 0.2
    new_rtt = alpha * x + (1 - alpha) * old_rtt
</code></pre>
<p>A weighting factor of 0.2 was chosen to put about 85% of the weight of the average RTT on the 9 most recent
observations.</p>
<h4 id="filtering-suitable-servers-based-on-the-latency-window"><a class="header" href="#filtering-suitable-servers-based-on-the-latency-window">Filtering suitable servers based on the latency window</a></h4>
<p>Server selection results in a set of zero or more suitable servers. If more than one server is suitable, a server MUST
be selected from among those within the latency window.</p>
<p>The <code>localThresholdMS</code> configuration parameter controls the size of the latency window used to select a suitable server.</p>
<p>The shortest average round trip time (RTT) from among suitable servers anchors one end of the latency window (<code>A</code>). The
other end is determined by adding <code>localThresholdMS</code> (<code>B = A + localThresholdMS</code>).</p>
<p>A server MUST be selected from among suitable servers that have an average RTT (<code>RTT</code>) within the latency window (i.e.
<code>A ≤ RTT ≤ B</code>). In other words, the suitable server with the shortest average RTT is <strong>always</strong> a possible choice. Other
servers could be chosen if their average RTTs are no more than <code>localThresholdMS</code> more than the shortest average RTT.</p>
<p>See either <a href="#single-threaded-server-selection">Single-threaded server selection</a> or
<a href="#multi-threaded-or-asynchronous-server-selection">Multi-threaded or asynchronous server selection</a> for information on
how to select a server from among those within the latency window.</p>
<h3 id="checking-an-idle-socket-after-socketcheckintervalms"><a class="header" href="#checking-an-idle-socket-after-socketcheckintervalms">Checking an Idle Socket After socketCheckIntervalMS</a></h3>
<p>Only for single-threaded drivers.</p>
<p>If a server is selected that has an existing connection that has been idle for socketCheckIntervalMS, the driver MUST
check the connection with the "ping" command. If the ping succeeds, use the selected connection. If not, set the
server's type to Unknown and update the Topology Description according to the Server Discovery and Monitoring Spec, and
attempt <strong>once</strong> more to select a server.</p>
<p>The logic is expressed in this pseudocode. The algorithm for the "getServer" function is suggested below, in
<a href="#single-threaded-server-selection-implementation">Single-threaded server selection implementation</a>:</p>
<pre><code class="language-python">    def getConnection(criteria):
        # Get a server for writes, or a server matching read prefs, by
        # running the server selection algorithm.
        server = getServer(criteria)
        if not server:
            throw server selection error

        connection = server.connection
        if connection is NULL:
            # connect to server and return connection
        else if connection has been idle &lt; socketCheckIntervalMS:
            return connection
        else:
            try:
                use connection for "ping" command
                return connection
            except network error:
                close connection
                mark server Unknown and update Topology Description

                # Attempt *once* more to select.
                server = getServer(criteria)
                if not server:
                    throw server selection error

                # connect to server and return connection
</code></pre>
<p>See <a href="#what-is-the-purpose-of-socketcheckintervalms">What is the purpose of socketCheckIntervalMS?</a>.</p>
<h3 id="requests-and-pinning-deprecated"><a class="header" href="#requests-and-pinning-deprecated">Requests and Pinning Deprecated</a></h3>
<p>The prior read preference specification included the concept of a "request", which pinned a server to a thread for
subsequent, related reads. Requests and pinning are now <strong>deprecated</strong>. See
<a href="#what-happened-to-pinning">What happened to pinning?</a> for the rationale for this change.</p>
<p>Drivers with an existing request API MAY continue to provide it for backwards compatibility, but MUST document that
pinning for the request does not guarantee monotonic reads.</p>
<p>Drivers MUST NOT automatically pin the client or a thread to a particular server without an explicit <code>start_request</code> (or
comparable) method call.</p>
<p>Outside a legacy "request" API, drivers MUST use server selection for each individual read operation.</p>
<h3 id="logging"><a class="header" href="#logging">Logging</a></h3>
<p>Please refer to the <a href="../logging/logging.html">logging specification</a> for details on logging implementations in general,
including log levels, log components, and structured versus unstructured logging.</p>
<p>Drivers MUST support logging of server selection information via the following log messages. These messages MUST use the
<code>serverSelection</code> log component.</p>
<p>The types used in the structured message definitions below are demonstrative, and drivers MAY use similar types instead
so long as the information is present (e.g. a double instead of an integer, or a string instead of an integer if the
structured logging framework does not support numeric types.)</p>
<h4 id="common-fields"><a class="header" href="#common-fields">Common Fields</a></h4>
<p>The following key-value pairs MUST be included in all server selection log messages:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Suggested Type</th><th>Value</th></tr></thead><tbody>
<tr><td>selector</td><td>String</td><td>String representation of the selector being used to select the server. This can be a read preference or an application-provided custom selector. The exact content of is flexible depending on what the driver is able to log. At minimum, when the selector is a read preference this string MUST contain all components of the read preference, and when it is an application-provided custom selector the string MUST somehow indicate that it is a custom selector.</td></tr>
<tr><td>operationId</td><td>Int</td><td>The driver-generated operation ID. Optional; only present if the driver generates operation IDs and this command has one.</td></tr>
<tr><td>operation</td><td>String</td><td>The name of the operation for which a server is being selected. When server selection is being performed to select a server for a command, this MUST be the command name.</td></tr>
<tr><td>topologyDescription</td><td>String</td><td>String representation of the current topology description. The format of is flexible and could be e.g. the <code>toString()</code> implementation for a driver's topology type, or an extended JSON representation of the topology object.</td></tr>
</tbody></table>
</div>
<h4 id="server-selection-started-message"><a class="header" href="#server-selection-started-message">"Server selection started" message</a></h4>
<p>This message MUST be logged at <code>debug</code> level. It MUST be emitted on the occasions specified either in
<a href="#multi-threaded-or-asynchronous-server-selection">Multi-threaded or asynchronous server selection</a> or
<a href="#single-threaded-server-selection">Single-threaded server selection</a>, depending on which algorithm the driver
implements.</p>
<p>This message MUST contain the following key-value pairs:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Suggested Type</th><th>Value</th></tr></thead><tbody>
<tr><td>message</td><td>String</td><td>"Server selection started"</td></tr>
</tbody></table>
</div>
<p>The unstructured form SHOULD be as follows, using the values defined in the structured format above to fill in
placeholders as appropriate:</p>
<blockquote>
<p>Server selection started for operation {{operation}} with ID {{operationId}}. Selector: {{selector}}, topology
description: {{topologyDescription}}</p>
</blockquote>
<h4 id="server-selection-succeeded-message"><a class="header" href="#server-selection-succeeded-message">"Server selection succeeded" message</a></h4>
<p>This message MUST be logged at <code>debug</code> level. It MUST be emitted on the occasions specified either in
<a href="#multi-threaded-or-asynchronous-server-selection">Multi-threaded or asynchronous server selection</a> or
<a href="#single-threaded-server-selection">Single-threaded server selection</a>, depending on which algorithm the driver
implements.</p>
<p>This message MUST contain the following key-value pairs:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Suggested Type</th><th>Value</th></tr></thead><tbody>
<tr><td>message</td><td>String</td><td>"Server selection succeeded"</td></tr>
<tr><td>serverHost</td><td>String</td><td>The hostname, IP address, or Unix domain socket path for the selected server.</td></tr>
<tr><td>serverPort</td><td>Int</td><td>The port for the selected server. Optional; not present for Unix domain sockets. When the user does not specify a port and the default (27017) is used, the driver SHOULD include it here.</td></tr>
</tbody></table>
</div>
<p>The unstructured form SHOULD be as follows, using the values defined in the structured format above to fill in
placeholders as appropriate:</p>
<blockquote>
<p>Server selection succeeded for operation {{operation}} with ID {{operationId}}. Selected server:
{{serverHost}}:{{serverPort}}. Selector: {{selector}}, topology description: {{topologyDescription}}</p>
</blockquote>
<h4 id="server-selection-failed-message"><a class="header" href="#server-selection-failed-message">"Server selection failed" message</a></h4>
<p>This message MUST be logged at <code>debug</code> level. It MUST be emitted on the occasions specified either in
<a href="#multi-threaded-or-asynchronous-server-selection">Multi-threaded or asynchronous server selection</a> or
<a href="#single-threaded-server-selection">Single-threaded server selection</a>, depending on which algorithm the driver
implements.</p>
<p>This message MUST contain the following key-value pairs:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Suggested Type</th><th>Value</th></tr></thead><tbody>
<tr><td>message</td><td>String</td><td>"Server selection failed"</td></tr>
<tr><td>failure</td><td>Flexible</td><td>Representation of the error the driver will throw regarding server selection failing. The type and format of this value is flexible; see the <a href="../logging/logging.html#representing-errors-in-log-messages">logging specification</a> for details on representing errors in log messages. Drivers MUST take care to not include any information in this field that is already included in the log message; e.g. the topology description should not be duplicated within this field.</td></tr>
</tbody></table>
</div>
<p>The unstructured form SHOULD be as follows, using the values defined in the structured format above to fill in
placeholders as appropriate:</p>
<blockquote>
<p>Server selection failed for operation {{operationName}} with ID {{operationId}}. Failure: {{failure}}. Selector:
{{selector}}, topology description: {{topologyDescription}}</p>
</blockquote>
<h4 id="waiting-for-suitable-server-to-become-available-message"><a class="header" href="#waiting-for-suitable-server-to-become-available-message">"Waiting for suitable server to become available" message</a></h4>
<p>This message MUST be logged at <code>info</code> level. It MUST be emitted on the occasions specified either in
<a href="#multi-threaded-or-asynchronous-server-selection">Multi-threaded or asynchronous server selection</a> or
<a href="#single-threaded-server-selection">Single-threaded server selection</a>, depending on which algorithm the driver
implements.</p>
<p>In order to avoid generating redundant log messages, the driver MUST take care to only emit this message once per
operation. We only log the message once because the only values that can change over time are:</p>
<ul>
<li>The remaining time: given the initial message's timestamp and the initial timestamp, the time remaining can always be
inferred from the original message.</li>
<li>The topology description: rather than logging these changes on a per-operation basis, users should observe them with a
single set of messages for the entire client via SDAM log messages.</li>
</ul>
<p>This message MUST contain the following key-value pairs:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Suggested Type</th><th>Value</th></tr></thead><tbody>
<tr><td>message</td><td>String</td><td>"Waiting for suitable server to become available"</td></tr>
<tr><td>remainingTimeMS</td><td>Int</td><td>The remaining time left until server selection will time out. This MAY be omitted if the driver supports disabling server selection timeout altogether.</td></tr>
</tbody></table>
</div>
<p>The unstructured form SHOULD be as follows, using the values defined in the structured format above to fill in
placeholders as appropriate:</p>
<blockquote>
<p>Waiting for server to become available for operation {{operationName}} with ID {{operationId}}. Remaining time:
{{remainingTimeMS}} ms. Selector: {{selector}}, topology description: {{topologyDescription}}.</p>
</blockquote>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<p>These are suggestions. As always, driver authors should balance cross-language standardization with backwards
compatibility and the idioms of their language.</p>
<h3 id="modes"><a class="header" href="#modes">Modes</a></h3>
<p>Modes ('primary', 'secondary', ...) are constants declared in whatever way is idiomatic for the programming language.
The constant values may be ints, strings, or whatever. However, when attaching modes to <code>$readPreference</code> camel case
must be used as described above in
<a href="#passing-read-preference-to-mongos-and-load-balancers">Passing read preference to mongos and load balancers</a>.</p>
<h4 id="primarypreferred-and-secondarypreferred"><a class="header" href="#primarypreferred-and-secondarypreferred">primaryPreferred and secondaryPreferred</a></h4>
<p>'primaryPreferred' is equivalent to selecting a server with read preference mode 'primary' (without <code>tag_sets</code> or
<code>maxStalenessSeconds</code>), or, if that fails, falling back to selecting with read preference mode 'secondary' (with
<code>tag_sets</code> and <code>maxStalenessSeconds</code>, if provided).</p>
<p>'secondaryPreferred' is the inverse: selecting with mode 'secondary' (with <code>tag_sets</code> and <code>maxStalenessSeconds</code>) and
falling back to selecting with mode 'primary' (without <code>tag_sets</code> or <code>maxStalenessSeconds</code>).</p>
<p>Depending on the implementation, this may result in cleaner code.</p>
<h4 id="nearest"><a class="header" href="#nearest">nearest</a></h4>
<p>The term 'nearest' is unfortunate, as it implies a choice based on geographic locality or absolute lowest latency,
neither of which are true.</p>
<p>Instead, and unlike the other read preference modes, 'nearest' does not favor either primaries or secondaries; instead
all servers are candidates and are filtered by <code>tag_sets</code> and <code>maxStalenessSeconds</code>.</p>
<p>To always select the server with the lowest RTT, users should use mode 'nearest' without <code>tag_sets</code> or
<code>maxStalenessSeconds</code> and set <code>localThresholdMS</code> to zero.</p>
<p>To distribute reads across all members evenly regardless of RTT, users should use mode 'nearest' without <code>tag_sets</code> or
<code>maxStalenessSeconds</code> and set <code>localThresholdMS</code> very high so that all servers fall within the latency window.</p>
<p>In both cases, <code>tag_sets</code> and <code>maxStalenessSeconds</code> could be used to further restrict the set of eligible servers, if
desired.</p>
<h3 id="tag-set-lists"><a class="header" href="#tag-set-lists">Tag set lists</a></h3>
<p>Tag set lists can be configured in the driver in whatever way is natural for the language.</p>
<h3 id="multi-threaded-server-selection-implementation"><a class="header" href="#multi-threaded-server-selection-implementation">Multi-threaded server selection implementation</a></h3>
<p>The following example uses a single lock for clarity. Drivers are free to implement whatever concurrency model best
suits their design.</p>
<p>The following is pseudocode for
<a href="#multi-threaded-or-asynchronous-server-selection">multi-threaded or asynchronous server selection</a>:</p>
<pre><code class="language-python">    def getServer(criteria):
        client.lock.acquire()

        now = gettime()
        endTime = now + computed server selection timeout

        log a "server selection started" message
        while true:
            # The topologyDescription keeps track of whether any server has an
            # an invalid wire version range
            if not topologyDescription.compatible:
                client.lock.release()
                log a "server selection failed" message
                throw invalid wire protocol range error with details

            if maxStalenessSeconds is set:
                if client minWireVersion &lt; 5 and "&lt;any available server's maxWireVersion &lt; 5"&gt;:
                    client.lock.release()
                    throw error

                if topologyDescription.type in (ReplicaSetWithPrimary, ReplicaSetNoPrimary):
                    if (maxStalenessSeconds * 1000 &lt; heartbeatFrequencyMS + idleWritePeriodMS or
                        maxStalenessSeconds &lt; smallestMaxStalenessSeconds):
                    client.lock.release()
                    throw error

            servers = all servers in topologyDescription matching criteria

            if serverSelector is not null:
                servers = serverSelector(servers)

            if servers is not empty:
                in_window = servers within the latency window
                if len(in_window) == 1:
                    selected = in_window[0]
                else:
                    server1, server2 = random two entries from in_window
                    if server1.operation_count &lt;= server2.operation_count:
                        selected = server1
                    else:
                        selected = server2
                selected.operation_count += 1
                client.lock.release()
                return selected

            request that all monitors check immediately
            if the message was not logged already for this operation: 
                log a "waiting for suitable server to become available" message

            # Wait for a new TopologyDescription. condition.wait() releases
            # client.lock while waiting and reacquires it before returning.
            # While a thread is waiting on client.condition, it is awakened
            # early whenever a server check completes.
            timeout_left = endTime - gettime()
            client.condition.wait(timeout_left)

            if now after endTime:
                client.lock.release()
                throw server selection error
</code></pre>
<h3 id="single-threaded-server-selection-implementation"><a class="header" href="#single-threaded-server-selection-implementation">Single-threaded server selection implementation</a></h3>
<p>The following is pseudocode for <a href="#single-threaded-server-selection">single-threaded server selection</a>:</p>
<pre><code class="language-python">    def getServer(criteria):
        startTime = gettime()
        loopEndTime = startTime
        maxTime = startTime + computed server selection timeout
        nextUpdateTime = topologyDescription.lastUpdateTime
                       + heartbeatFrequencyMS/1000:

        if nextUpdateTime &lt; startTime:
            topologyDescription.stale = true

        while true:

            if topologyDescription.stale:
                scanReadyTime = topologyDescription.lastUpdateTime
                              + minHeartbeatFrequencyMS/1000

                if ((not serverSelectionTryOnce) &amp;&amp; (scanReadyTime &gt; maxTime)):
                    throw server selection error with details

                # using loopEndTime below is a proxy for "now" but avoids
                # the overhead of another gettime() call
                sleepTime = scanReadyTime - loopEndTime

                if sleepTime &gt; 0:
                    sleep sleepTime

                rescan all servers
                topologyDescription.lastupdateTime = gettime()
                topologyDescription.stale = false

            # topologyDescription keeps a record of whether any
            # server has an incompatible wire version range
            if not topologyDescription.compatible:
                topologyDescription.stale = true
                # throw invalid wire version range error with details

            if maxStalenessSeconds is set:
                if client minWireVersion &lt; 5 and "&lt;any available server's maxWireVersion &lt; 5&gt;":
                    # throw error

                if topologyDescription.type in (ReplicaSetWithPrimary, ReplicaSetNoPrimary):
                    if (maxStalenessSeconds * 1000 &lt; heartbeatFrequencyMS + idleWritePeriodMS or
                        maxStalenessSeconds &lt; smallestMaxStalenessSeconds):
                    # throw error

            servers = all servers in topologyDescription matching criteria

            if serverSelector is not null:
                servers = serverSelector(servers)

            if servers is not empty:
                in_window = servers within the latency window
                return random entry from in_window
            else:
                topologyDescription.stale = true

            loopEndTime = gettime()

            if serverSelectionTryOnce:
                if topologyDescription.lastUpdateTime &gt; startTime:
                    throw server selection error with details
            else if loopEndTime &gt; maxTime:
                throw server selection error with details

            if the message was not logged already: 
                log a "waiting for suitable server to become available" message
</code></pre>
<h3 id="server-selection-errors"><a class="header" href="#server-selection-errors">Server Selection Errors</a></h3>
<p>Drivers should use server descriptions and their error attributes (if set) to return useful error messages.</p>
<p>For example, when there are no members matching the ReadPreference:</p>
<ul>
<li>"No server available for query with ReadPreference primary"</li>
<li>"No server available for query with ReadPreference secondary"</li>
<li>"No server available for query with ReadPreference " + mode + ", tag set list " + tag_sets + ", and
<code>maxStalenessSeconds</code> " + maxStalenessSeconds</li>
</ul>
<p>Or, if authentication failed:</p>
<ul>
<li>"Authentication failed: <code>[specific error message]</code>"</li>
</ul>
<p>Here is a sketch of some pseudocode for handling error reporting when errors could be different across servers:</p>
<pre><code class="language-python">    if there are any available servers:
        error_message = "No servers are suitable for " + criteria
    else if all ServerDescriptions' errors are the same:
        error_message = a ServerDescription.error value
    else:
        error_message = ', '.join(all ServerDescriptions' errors)
</code></pre>
<h3 id="cursors"><a class="header" href="#cursors">Cursors</a></h3>
<p>Cursor operations OP_GET_MORE and OP_KILL_CURSOR do not go through the server selection process. Cursor operations must
be sent to the original server that received the query and sent the OP_REPLY. For exhaust cursors, the same socket must
be used for OP_GET_MORE until the cursor is exhausted.</p>
<h3 id="sharded-transactions"><a class="header" href="#sharded-transactions">Sharded Transactions</a></h3>
<p>Operations that are part of a sharded transaction (after the initial command) do not go through the server selection
process. Sharded transaction operations MUST be sent to the original mongos server on which the transaction was started.</p>
<h3 id="the-text-command-and-mongos"><a class="header" href="#the-text-command-and-mongos">The 'text' command and mongos</a></h3>
<p><em>Note</em>: As of MongoDB 2.6, mongos doesn't distribute the "text" command to secondaries, see
<a href="https://jira.mongodb.org/browse/SERVER-10947">SERVER-10947</a>.</p>
<p>However, the "text" command is deprecated in 2.6, so this command-specific helper may become deprecated before this is
fixed.</p>
<h2 id="test-plan"><a class="header" href="#test-plan">Test Plan</a></h2>
<p>The server selection test plan is given in a separate document that describes the tests and supporting data files:
<a href="./server-selection-tests.html">Server Selection Tests</a></p>
<h2 id="design-rationale"><a class="header" href="#design-rationale">Design Rationale</a></h2>
<h3 id="use-of-topology-types"><a class="header" href="#use-of-topology-types">Use of topology types</a></h3>
<p>The prior version of the read preference spec had only a loose definition of server or topology types. The
<a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> spec defines
these terms explicitly and they are used here for consistency and clarity.</p>
<h3 id="consistency-with-mongos"><a class="header" href="#consistency-with-mongos">Consistency with mongos</a></h3>
<p>In order to ensure that behavior is consistent regardless of topology type, read preference behaviors are limited to
those that mongos can proxy.</p>
<p>For example, mongos ignores read preference 'secondary' when a shard consists of a single server. Therefore, this spec
calls for topology type Single to ignore read preferences for consistency.</p>
<p>The spec has been written with the intention that it can apply to both drivers and mongos and the term "client" has been
used when behaviors should apply to both. Behaviors that are specific to drivers are largely limited to those for
communicating with a mongos.</p>
<h3 id="new-localthresholdms-configuration-option-name"><a class="header" href="#new-localthresholdms-configuration-option-name">New localThresholdMS configuration option name</a></h3>
<p>Because this does not apply <strong>only</strong> to secondaries and does not limit absolute latency, the name
<code>secondaryAcceptableLatencyMS</code> is misleading.</p>
<p>The mongos name <code>localThreshold</code> misleads because it has nothing to do with locality. It also doesn't include the <code>MS</code>
units suffix for consistency with other time-related configuration options.</p>
<p>However, given a choice between the two, <code>localThreshold</code> is a more general term. For drivers, we add the <code>MS</code> suffix
for clarity about units and consistency with other configuration options.</p>
<h3 id="random-selection-within-the-latency-window-single-threaded"><a class="header" href="#random-selection-within-the-latency-window-single-threaded">Random selection within the latency window (single-threaded)</a></h3>
<p>When more than one server is judged to be suitable, the spec calls for random selection to ensure a fair distribution of
work among servers within the latency window.</p>
<p>It would be hard to ensure a fair round-robin approach given the potential for servers to come and go. Making newly
available servers either first or last could lead to unbalanced work. Random selection has a better fairness guarantee
and keeps the design simpler.</p>
<h3 id="operationcount-based-selection-within-the-latency-window-multi-threaded-or-async"><a class="header" href="#operationcount-based-selection-within-the-latency-window-multi-threaded-or-async">operationCount-based selection within the latency window (multi-threaded or async)</a></h3>
<p>As operation execution slows down on a node (e.g. due to degraded server-side performance or increased network latency),
checked-out pooled connections to that node will begin to remain checked out for longer periods of time. Assuming at
least constant incoming operation load, more connections will then need to be opened against the node to service new
operations that it gets selected for, further straining it and slowing it down. This can lead to runaway connection
creation scenarios that can cripple a deployment ("connection storms"). As part of DRIVERS-781, the random choice
portion of multi-threaded server selection was changed to more evenly spread out the workload among suitable servers in
order to prevent any single node from being overloaded. The new steps achieve this by approximating an individual
server's load via the number of concurrent operations that node is processing (operationCount) and then routing
operations to servers with less load. This should reduce the number of new operations routed towards nodes that are
busier and thus increase the number routed towards nodes that are servicing operations faster or are simply less busy.
The previous random selection mechanism did not take load into account and could assign work to nodes that were under
too much stress already.</p>
<p>As an added benefit, the new approach gives preference to nodes that have recently been discovered and are thus are more
likely to be alive (e.g. during a rolling restart). The narrowing to two random choices first ensures new servers aren't
overly preferred however, preventing a "thundering herd" situation. Additionally, the
<a href="../connection-monitoring-and-pooling/connection-monitoring-and-pooling.html#connection-pool">maxConnecting</a> provisions
included in the CMAP specification prevent drivers from crippling new nodes with connection storms.</p>
<p>This approach is based on the
<a href="https://web.archive.org/web/20191212194243/https://www.nginx.com/blog/nginx-power-of-two-choices-load-balancing-algorithm/">"Power of Two Random Choices with Least Connections"</a>
load balancing algorithm.</p>
<p>An alternative approach to this would be to prefer selecting servers that already have available connections. While that
approach could help reduce latency, it does not achieve the benefits of routing operations away from slow servers or of
preferring newly introduced servers. Additionally, that approach could lead to the same node being selected repeatedly
rather than spreading the load out among all suitable servers.</p>
<h3 id="the-secondaryok-wire-protocol-flag"><a class="header" href="#the-secondaryok-wire-protocol-flag">The SecondaryOk wire protocol flag</a></h3>
<p>In server selection, there is a race condition that could exist between what a selected server type is believed to be
and what it actually is.</p>
<p>The <code>SecondaryOk</code> wire protocol flag solves the race problem by communicating to the server whether a secondary is
acceptable. The server knows its type and can return a "not writable primary" error if <code>SecondaryOk</code> is false and the
server is a secondary.</p>
<p>However, because topology type Single is used for direct connections, we want read operations to succeed even against a
secondary, so the <code>SecondaryOk</code> wire protocol flag must be sent to mongods with topology type Single.</p>
<p>(If the server type is Mongos, follow the rules for
<a href="#passing-read-preference-to-mongos-and-load-balancers">Passing read preference to mongos and load balancers</a>, even for
topology type Single.)</p>
<h3 id="general-command-method-going-to-primary"><a class="header" href="#general-command-method-going-to-primary">General command method going to primary</a></h3>
<p>The list of commands that can go to secondaries changes over time and depends not just on the command but on parameters.
For example, the <code>mapReduce</code> command may or may not be able to be run on secondaries depending on the value of the <code>out</code>
parameter.</p>
<p>It significantly simplifies implementation for the general command method always to go to the primary unless a explicit
read preference is set and rely on users of the general command method to provide a read preference appropriate to the
command.</p>
<p>The command-specific helpers will need to implement a check of read preferences against the semantics of the command and
its parameters, but keeping this logic close to the command rather than in a generic method is a better design than
either delegating this check to the generic method, duplicating the logic in the generic method, or coupling both to
another validation method.</p>
<h3 id="average-round-trip-time-calculation"><a class="header" href="#average-round-trip-time-calculation">Average round trip time calculation</a></h3>
<p>Using an exponentially-weighted moving average avoids having to store and rotate an arbitrary number of RTT
observations. All observations count towards the average. The weighting makes recent observations count more heavily
while smoothing volatility.</p>
<h3 id="verbose-errors"><a class="header" href="#verbose-errors">Verbose errors</a></h3>
<p>Error messages should be sufficiently verbose to allow users and/or support engineers to determine the reasons for
server selection failures from log or other error messages.</p>
<h3 id="try-once-mode"><a class="header" href="#try-once-mode">"Try once" mode</a></h3>
<p>Single-threaded drivers in languages like PHP and Perl are typically deployed as many processes per application server.
Each process must independently discover and monitor the MongoDB deployment.</p>
<p>When no suitable server is available (due to a partition or misconfiguration), it is better for each request to fail as
soon as its process detects a problem, instead of waiting and retrying to see if the deployment recovers.</p>
<p>Minimizing response latency is important for maximizing request-handling capacity and for user experience (e.g. a quick
fail message instead of a slow web page).</p>
<p>However, when a request arrives and the topology information is already stale, or no suitable server is known, making a
single attempt to update the topology to service the request is acceptable.</p>
<p>A user of a single-threaded driver who prefers resilience in the face of topology problems, rather than short response
times, can turn the "try once" mode off. Then driver rescans the topology every minHeartbeatFrequencyMS until a suitable
server is found or the timeout expires.</p>
<h3 id="what-is-the-purpose-of-socketcheckintervalms"><a class="header" href="#what-is-the-purpose-of-socketcheckintervalms">What is the purpose of socketCheckIntervalMS?</a></h3>
<p>Single-threaded clients need to make a compromise: if they check servers too frequently it slows down regular
operations, but if they check too rarely they cannot proactively avoid errors.</p>
<p>Errors are more disruptive for single-threaded clients than for multi-threaded. If one thread in a multi-threaded
process encounters an error, it warns the other threads not to use the disconnected server. But single-threaded clients
are deployed as many independent processes per application server, and each process must throw an error until all have
discovered that a server is down.</p>
<p>The compromise specified here balances the cost of frequent checks against the disruption of many errors. The client
preemptively checks individual sockets that have not been used in the last
<a href="#socketcheckintervalms">socketCheckIntervalMS</a>, which is more frequent by default than <code>heartbeatFrequencyMS</code> defined
in the Server Discovery and Monitoring Spec.</p>
<p>The client checks the socket with a "ping" command, rather than "hello" or legacy hello, because it is not checking the
server's full state as in the Server Discovery and Monitoring Spec, it is only verifying that the connection is still
open. We might also consider a <code>select</code> or <code>poll</code> call to check if the socket layer considers the socket closed, without
requiring a round-trip to the server. However, this technique usually will not detect an uncleanly shutdown server or a
network outage.</p>
<h2 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<p>In general, backwards breaking changes have been made in the name of consistency with mongos and avoiding misleading
users about monotonicity.</p>
<ul>
<li>
<p>Features removed:</p>
<blockquote>
<ul>
<li>Automatic pinning (see <a href="#what-happened-to-pinning">What happened to pinning?</a>)</li>
<li>Auto retry (replaced by the general server selection algorithm)</li>
<li>mongos "high availability" mode (effectively, mongos pinning)</li>
</ul>
</blockquote>
</li>
<li>
<p>Other features and behaviors have changed explicitly</p>
<blockquote>
<ul>
<li>Ignoring read preferences for topology type Single</li>
<li>Default read preference for the generic command method</li>
</ul>
</blockquote>
</li>
<li>
<p>Changes with grandfather clauses</p>
<blockquote>
<ul>
<li>Alternate names for <code>localThresholdMS</code></li>
<li>Pinning for legacy request APIs</li>
</ul>
</blockquote>
</li>
<li>
<p>Internal changes with little user-visibility</p>
<blockquote>
<ul>
<li>Clarifying calculation of average RTT</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="questions-and-answers"><a class="header" href="#questions-and-answers">Questions and Answers</a></h2>
<h3 id="what-happened-to-pinning"><a class="header" href="#what-happened-to-pinning">What happened to pinning?</a></h3>
<p>The prior read preference spec, which was implemented in the versions of the drivers and mongos released concomitantly
with MongoDB 2.2, stated that a thread / client should remain pinned to an RS member as long as that member matched the
current mode, tags, and acceptable latency. This increased the odds that reads would be monotonic (assuming no
rollback), but had the following surprising consequence:</p>
<ol>
<li>Thread / client reads with mode 'secondary' or 'secondaryPreferred', gets pinned to a secondary</li>
<li>Thread / client reads with mode 'primaryPreferred', driver / mongos sees that the pinned member (a secondary) matches
the mode (which <em>allows</em> for a secondary) and reads from secondary, even though the primary is available and
preferable</li>
</ol>
<p>The old spec also had the swapped problem, reading from the primary with 'secondaryPreferred', except for mongos which
was changed at the last minute before release with <a href="https://jira.mongodb.org/browse/SERVER-6565">SERVER-6565</a>.</p>
<p>This left application developers with two problems:</p>
<ol>
<li>'primaryPreferred' and 'secondaryPreferred' acted surprisingly and unpredictably within requests</li>
<li>There was no way to specify a common need: read from a secondary if possible with 'secondaryPreferred', then from
primary if possible with 'primaryPreferred', all within a request. Instead an application developer would have to do
the second read with 'primary', which would unpin the thread but risk unavailability if only secondaries were up.</li>
</ol>
<p>Additionally, mongos 2.4 introduced the releaseConnectionsAfterResponse option (RCAR), mongos 2.6 made it the default
and mongos 2.8 will remove the ability to turn it off. This means that pinning to a mongos offers no guarantee that
connections to shards are pinned. Since we can't provide the same guarantees for replica sets and sharded clusters, we
removed automatic pinning entirely and deprecated "requests". See
<a href="https://jira.mongodb.org/browse/SERVER-11956">SERVER-11956</a> and
<a href="https://jira.mongodb.org/browse/SERVER-12273">SERVER-12273</a>.</p>
<p>Regardless, even for replica sets, pinning offers no monotonicity because of the ever-present possibility of rollbacks.
Through MongoDB 2.6, secondaries did not close sockets on rollback, so a rollback could happen between any two queries
without any indication to the driver.</p>
<p>Therefore, an inconsistent feature that doesn't actually do what people think it does has no place in the spec and has
been removed. Should the server eventually implement some form of "sessions", this spec will need to be revised
accordingly.</p>
<h3 id="why-change-from-mongos-high-availability-ha-to-random-selection"><a class="header" href="#why-change-from-mongos-high-availability-ha-to-random-selection">Why change from mongos High Availability (HA) to random selection?</a></h3>
<p>Mongos HA has similar problems with pinning, in that one can wind up pinned to a high-latency mongos even if a
lower-latency mongos later becomes available.</p>
<p>Selection within the latency window avoids this problem and makes server selection exactly analogous to having multiple
suitable servers from a replica set. This is easier to explain and implement.</p>
<h3 id="what-happened-to-auto-retry"><a class="header" href="#what-happened-to-auto-retry">What happened to auto-retry?</a></h3>
<p>The old auto-retry mechanism was closely connected to server pinning, which has been removed. It also mandated exactly
three attempts to carry out a query on different servers, with no way to disable or adjust that value, and only for the
first query within a request.</p>
<p>To the extent that auto-retry was trying to compensate for unavailable servers, the Server Discovery and Monitoring spec
and new server selection algorithm provide a more robust and configurable way to direct <em>all</em> queries to available
servers.</p>
<p>After a server is selected, several error conditions could still occur that make the selected server unsuitable for
sending the operation, such as:</p>
<blockquote>
<ul>
<li>the server could have shutdown the socket (e.g. a primary stepping down),</li>
<li>a connection pool could be empty, requiring new connections; those connections could fail to connect or could fail
the server handshake</li>
</ul>
</blockquote>
<p>Once an operation is sent over the wire, several additional error conditions could occur, such as:</p>
<blockquote>
<ul>
<li>a socket timeout could occur before the server responds</li>
<li>the server might send an RST packet, indicating the socket was already closed</li>
<li>for write operations, the server might return a "not writable primary" error</li>
</ul>
</blockquote>
<p>This specification does not require nor prohibit drivers from attempting automatic recovery for various cases where it
might be considered reasonable to do so, such as:</p>
<blockquote>
<ul>
<li>repeating server selection if, after selection, a socket is determined to be unsuitable before a message is sent on
it</li>
<li>for a read operation, after a socket error, selecting a new server meeting the read preference and resending the
query</li>
<li>for a write operation, after a "not writable primary" error, selecting a new server (to locate the primary) and
resending the write operation</li>
</ul>
</blockquote>
<p>Driver-common rules for retrying operations (and configuring such retries) could be the topic of a different, future
specification.</p>
<h3 id="why-is-maxstalenessseconds-applied-before-tag_sets"><a class="header" href="#why-is-maxstalenessseconds-applied-before-tag_sets">Why is maxStalenessSeconds applied before tag_sets?</a></h3>
<p>The intention of read preference's list of tag sets is to allow a user to prefer the first tag set but fall back to
members matching later tag sets. In order to know whether to fall back or not, we must first filter by all other
criteria.</p>
<p>Say you have two secondaries:</p>
<blockquote>
<ul>
<li>Node 1, tagged <code>{'tag': 'value1'}</code>, estimated staleness 5 minutes</li>
<li>Node 2, tagged <code>{'tag': 'value2'}</code>, estimated staleness 1 minute</li>
</ul>
</blockquote>
<p>And a read preference:</p>
<blockquote>
<ul>
<li>mode: "secondary"</li>
<li>maxStalenessSeconds: 120 (2 minutes)</li>
<li>tag_sets: <code>[{'tag': 'value1'}, {'tag': 'value2'}]</code></li>
</ul>
</blockquote>
<p>If tag sets were applied before maxStalenessSeconds, we would select Node 1 since it matches the first tag set, then
filter it out because it is too stale, and be left with no eligible servers.</p>
<p>The user's intent in specifying two tag sets was to fall back to the second set if needed, so we filter by
maxStalenessSeconds first, then tag_sets, and select Node 2.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html">Server Discovery and Monitoring</a> specification</li>
<li><a href="../auth/auth.html">Driver Authentication</a> specification</li>
<li><a href="../connection-monitoring-and-pooling/connection-monitoring-and-pooling.html">Connection Monitoring and Pooling</a>
specification</li>
</ul>
<h2 id="changelog"><a class="header" href="#changelog">Changelog</a></h2>
<ul>
<li>
<p>2015-06-26: Updated single-threaded selection logic with "stale" and serverSelectionTryOnce.</p>
</li>
<li>
<p>2015-08-10: Updated single-threaded selection logic to ensure a scan always happens at least once under
serverSelectionTryOnce if selection fails. Removed the general selection algorithm and put full algorithms for each of
the single- and multi-threaded sections. Added a requirement that single-threaded drivers document selection time
expectations.</p>
</li>
<li>
<p>2016-07-21: Updated for Max Staleness support.</p>
</li>
<li>
<p>2016-08-03: Clarify selection algorithm, in particular that maxStalenessMS comes before tag_sets.</p>
</li>
<li>
<p>2016-10-24: Rename option from "maxStalenessMS" to "maxStalenessSeconds".</p>
</li>
<li>
<p>2016-10-25: Change minimum maxStalenessSeconds value from 2 * heartbeatFrequencyMS to heartbeatFrequencyMS +
idleWritePeriodMS (with proper conversions of course).</p>
</li>
<li>
<p>2016-11-01: Update formula for secondary staleness estimate with the equivalent, and clearer, expression of this
formula from the Max Staleness Spec</p>
</li>
<li>
<p>2016-11-21: Revert changes that would allow idleWritePeriodMS to change in the future, require maxStalenessSeconds to
be at least 90.</p>
</li>
<li>
<p>2017-06-07: Clarify socketCheckIntervalMS behavior, single-threaded drivers must retry selection after checking an
idle socket and discovering it is broken.</p>
</li>
<li>
<p>2017-11-10: Added application-configurated server selector.</p>
</li>
<li>
<p>2017-11-12: Specify read preferences for OP_MSG with direct connection, and delete obsolete comment direct connections
to secondaries getting "not writable primary" errors by design.</p>
</li>
<li>
<p>2018-01-22: Clarify that $query wrapping is only for OP_QUERY</p>
</li>
<li>
<p>2018-01-22: Clarify that $out on aggregate follows the "$out Aggregation Pipeline Operator" spec and warns if read
preference is not primary.</p>
</li>
<li>
<p>2018-01-29: Remove reference to '$out Aggregation spec'. Clarify runCommand selection rules.</p>
</li>
<li>
<p>2018-12-13: Update tag_set example to use only String values</p>
</li>
<li>
<p>2019-05-20: Added rule to not send read preferene to standalone servers</p>
</li>
<li>
<p>2019-06-07: Clarify language for aggregate and mapReduce commands that write</p>
</li>
<li>
<p>2020-03-17: Specify read preferences with support for server hedged reads</p>
</li>
<li>
<p>2020-10-10: Consider server load when selecting servers within the latency window.</p>
</li>
<li>
<p>2021-04-07: Adding in behaviour for load balancer mode.</p>
</li>
<li>
<p>2021-05-12: Removed deprecated URI option in favour of readPreference=secondaryPreferred.</p>
</li>
<li>
<p>2021-05-13: Updated to use modern terminology.</p>
</li>
<li>
<p>2021-08-05: Updated $readPreference logic to describe OP_MSG behavior.</p>
</li>
<li>
<p>2021-09-03: Clarify that wire version check only applies to available servers.</p>
</li>
<li>
<p>2021-09-28: Note that 5.0+ secondaries support aggregate with write stages (e.g. <code>$out</code> and <code>$merge</code>). Clarify setting
<code>SecondaryOk</code> wire protocol flag or <code>$readPreference</code> global command argument for replica set topology.</p>
</li>
<li>
<p>2022-01-19: Require that timeouts be applied per the client-side operations timeout spec</p>
</li>
<li>
<p>2022-10-05: Remove spec front matter, move footnote, and reformat changelog.</p>
</li>
<li>
<p>2022-11-09: Add log messages and tests.</p>
</li>
<li>
<p>2023-08-26: Add list of deprioritized servers for sharded cluster topology.</p>
</li>
<li>
<p>2024-02-07: Migrated from reStructuredText to Markdown.</p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>mongos 3.4 refuses to connect to mongods with maxWireVersion &lt; 5, so it does no additional wire version checks
related to maxStalenessSeconds.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../polling-srv-records-for-mongos-discovery/polling-srv-records-for-mongos-discovery.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../max-staleness/max-staleness.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../polling-srv-records-for-mongos-discovery/polling-srv-records-for-mongos-discovery.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../max-staleness/max-staleness.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
