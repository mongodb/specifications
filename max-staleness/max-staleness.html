<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Max Staleness - MongoDB Driver Specifications</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../driver-mantras.html">Mantras</a></li><li class="chapter-item expanded affix "><a href="../wireversion-featurelist/wireversion-featurelist.html">Wire Version Feature List</a></li><li class="chapter-item expanded affix "><li class="part-title">Specifications</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Serialization</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../BSON.html"><strong aria-hidden="true">1.1.</strong> BSON</a></li><li class="chapter-item expanded "><a href="../bson-objectid/objectid.html"><strong aria-hidden="true">1.2.</strong> ObjectId</a></li><li class="chapter-item expanded "><a href="../bson-decimal128/decimal128.html"><strong aria-hidden="true">1.3.</strong> Decimal128</a></li><li class="chapter-item expanded "><a href="../bson-binary-uuid/uuid.html"><strong aria-hidden="true">1.4.</strong> UUID</a></li><li class="chapter-item expanded "><a href="../dbref/dbref.html"><strong aria-hidden="true">1.5.</strong> DBRef</a></li><li class="chapter-item expanded "><a href="../extended-json/extended-json.html"><strong aria-hidden="true">1.6.</strong> Extended JSON</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Communication</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../message/OP_MSG.html"><strong aria-hidden="true">2.1.</strong> OP_MSG</a></li><li class="chapter-item expanded "><a href="../run-command/run-command.html"><strong aria-hidden="true">2.2.</strong> Command Execution</a></li><li class="chapter-item expanded "><a href="../connection-string/connection-string-spec.html"><strong aria-hidden="true">2.3.</strong> Connection String</a></li><li class="chapter-item expanded "><a href="../uri-options/uri-options.html"><strong aria-hidden="true">2.4.</strong> URI Options</a></li><li class="chapter-item expanded "><a href="../ocsp-support/ocsp-support.html"><strong aria-hidden="true">2.5.</strong> OCSP</a></li><li class="chapter-item expanded "><a href="../mongodb-handshake/handshake.html"><strong aria-hidden="true">2.6.</strong> Initial Handshake</a></li><li class="chapter-item expanded "><a href="../compression/OP_COMPRESSED.html"><strong aria-hidden="true">2.7.</strong> Wire Compression</a></li><li class="chapter-item expanded "><a href="../socks5-support/socks5.html"><strong aria-hidden="true">2.8.</strong> SOCKS5</a></li><li class="chapter-item expanded "><a href="../initial-dns-seedlist-discovery/initial-dns-seedlist-discovery.html"><strong aria-hidden="true">2.9.</strong> Initial DNS Seedlist Discovery</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Connectivity</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server-discovery-and-monitoring/server-discovery-and-monitoring.html"><strong aria-hidden="true">3.1.</strong> Server Discovery and Monitoring</a></li><li class="chapter-item expanded "><a href="../connection-monitoring-and-pooling/connection-monitoring-and-pooling.html"><strong aria-hidden="true">3.2.</strong> Connection Monitoring and Pooling</a></li><li class="chapter-item expanded "><a href="../load-balancers/load-balancers.html"><strong aria-hidden="true">3.3.</strong> Load Balancer Support</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Availability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server-discovery-and-monitoring/server-monitoring.html"><strong aria-hidden="true">4.1.</strong> Server Monitoring</a></li><li class="chapter-item expanded "><a href="../polling-srv-records-for-mongos-discovery/polling-srv-records-for-mongos-discovery.html"><strong aria-hidden="true">4.2.</strong> SRV Polling for mongos Discovery</a></li><li class="chapter-item expanded "><a href="../server-selection/server-selection.html"><strong aria-hidden="true">4.3.</strong> Server Selection</a></li><li class="chapter-item expanded "><a href="../max-staleness/max-staleness.html" class="active"><strong aria-hidden="true">4.4.</strong> Max Staleness</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Resilience</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Retryability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../retryable-reads/retryable-reads.html"><strong aria-hidden="true">5.1.1.</strong> Reads</a></li><li class="chapter-item expanded "><a href="../retryable-writes/retryable-writes.html"><strong aria-hidden="true">5.1.2.</strong> Writes</a></li></ol></li><li class="chapter-item expanded "><a href="../client-side-operations-timeout/client-side-operations-timeout.html"><strong aria-hidden="true">5.2.</strong> CSOT</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Consistency</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../sessions/driver-sessions.html"><strong aria-hidden="true">5.3.1.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="../causal-consistency/causal-consistency.html"><strong aria-hidden="true">5.3.2.</strong> Causal Consistency</a></li><li class="chapter-item expanded "><a href="../sessions/snapshot-sessions.html"><strong aria-hidden="true">5.3.3.</strong> Snapshot Reads</a></li><li class="chapter-item expanded "><a href="../transactions/transactions.html"><strong aria-hidden="true">5.3.4.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="../transactions-convenient-api/transactions-convenient-api.html"><strong aria-hidden="true">5.3.5.</strong> Convenient Transactions API</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Resource Management</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../enumerate-databases/enumerate-databases.html"><strong aria-hidden="true">6.1.1.</strong> Databases</a></li><li class="chapter-item expanded "><a href="../enumerate-collections/enumerate-collections.html"><strong aria-hidden="true">6.1.2.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../index-management/index-management.html"><strong aria-hidden="true">6.1.3.</strong> Indexes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Data Management</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../crud/crud.html"><strong aria-hidden="true">6.2.1.</strong> CRUD</a></li><li class="chapter-item expanded "><a href="../collation/collation.html"><strong aria-hidden="true">6.2.2.</strong> Collation</a></li><li class="chapter-item expanded "><a href="../server_write_commands/server_write_commands.html"><strong aria-hidden="true">6.2.3.</strong> Write Commands</a></li><li class="chapter-item expanded "><a href="../driver-bulk-update.html"><strong aria-hidden="true">6.2.4.</strong> Bulk API</a></li><li class="chapter-item expanded "><a href="../crud/bulk-write.html"><strong aria-hidden="true">6.2.5.</strong> Bulk Write</a></li><li class="chapter-item expanded "><a href="../read-write-concern/read-write-concern.html"><strong aria-hidden="true">6.2.6.</strong> R/W Concern</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Cursors</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../change-streams/change-streams.html"><strong aria-hidden="true">6.3.1.</strong> Change Streams</a></li><li class="chapter-item expanded "><a href="../find_getmore_killcursors_commands/find_getmore_killcursors_commands.html"><strong aria-hidden="true">6.3.2.</strong> find/getMore/killCursors</a></li></ol></li><li class="chapter-item expanded "><a href="../gridfs/gridfs-spec.html"><strong aria-hidden="true">6.4.</strong> GridFS</a></li><li class="chapter-item expanded "><a href="../versioned-api/versioned-api.html"><strong aria-hidden="true">6.5.</strong> Stable API</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.</strong> Security</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../client-side-encryption/client-side-encryption.html"><strong aria-hidden="true">6.6.1.</strong> Client Side Encryption</a></li><li class="chapter-item expanded "><a href="../bson-binary-encrypted/binary-encrypted.html"><strong aria-hidden="true">6.6.2.</strong> BSON Binary Subtype 6</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Observability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../command-logging-and-monitoring/command-logging-and-monitoring.html"><strong aria-hidden="true">7.1.</strong> Command Logging and Monitoring</a></li><li class="chapter-item expanded "><a href="../server-discovery-and-monitoring/server-discovery-and-monitoring-logging-and-monitoring.html"><strong aria-hidden="true">7.2.</strong> SDAM Logging and Monitoring</a></li><li class="chapter-item expanded "><a href="../logging/logging.html"><strong aria-hidden="true">7.3.</strong> Standardized Logging</a></li><li class="chapter-item expanded "><a href="../connection-monitoring-and-pooling/connection-monitoring-and-pooling.html"><strong aria-hidden="true">7.4.</strong> Connection Pool Logging</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Testability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../unified-test-format/unified-test-format.html"><strong aria-hidden="true">8.1.</strong> Unified Test Format</a></li><li class="chapter-item expanded "><a href="../atlas-data-lake-testing/tests/index.html"><strong aria-hidden="true">8.2.</strong> Atlas Data Federation Testing</a></li><li class="chapter-item expanded "><a href="../benchmarking/benchmarking.html"><strong aria-hidden="true">8.3.</strong> Performance Benchmarking</a></li><li class="chapter-item expanded "><a href="../bson-corpus/bson-corpus.html"><strong aria-hidden="true">8.4.</strong> BSON Corpus</a></li><li class="chapter-item expanded "><a href="../connections-survive-step-down/tests/index.html"><strong aria-hidden="true">8.5.</strong> Replication Event Resilience</a></li><li class="chapter-item expanded "><a href="../faas-automated-testing/faas-automated-testing.html"><strong aria-hidden="true">8.6.</strong> FAAS Automated Testing</a></li><li class="chapter-item expanded "><a href="../serverless-testing/index.html"><strong aria-hidden="true">8.7.</strong> Atlas Serverless Testing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MongoDB Driver Specifications</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="max-staleness"><a class="header" href="#max-staleness">Max Staleness</a></h1>
<ul>
<li>Status: Accepted</li>
<li>Minimum Server Version: 3.4</li>
</ul>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>Read preference gains a new option, "maxStalenessSeconds".</p>
<p>A client (driver or mongos) MUST estimate the staleness of each secondary, based on lastWriteDate values provided in
server hello responses, and select only those secondaries whose staleness is less than or equal to maxStalenessSeconds.</p>
<p>Most of the implementation of the maxStalenessSeconds option is specified in the Server Discovery And Monitoring Spec
and the Server Selection Spec. This document supplements those specs by collecting information specifically about
maxStalenessSeconds.</p>
<h2 id="meta"><a class="header" href="#meta">Meta</a></h2>
<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.</p>
<h2 id="motivation-for-change"><a class="header" href="#motivation-for-change">Motivation for Change</a></h2>
<p>Users have often asked for ways to avoid reading from stale secondaries. An application with a geographically
distributed replica set may want to prefer nearby members to minimize latency, while at the same time avoiding extremely
laggy secondaries to mitigate the risk of very stale reads.</p>
<h3 id="goals"><a class="header" href="#goals">Goals</a></h3>
<ul>
<li>Provide an approximate means of limiting the staleness of secondary reads.</li>
<li>Provide a client-side knob to adjust the tradeoff between network-local reads and data recency.</li>
<li>Be robust in the face of clock skew between the client and servers, and skew between the primary and secondaries.</li>
<li>Avoid "inadvertent primary read preference": prevent a maxStalenessSeconds setting so small it forces all reads to the
primary regardless of actual replication lag.</li>
<li>Specify how mongos routers and shards track the opTimes of Config Servers as Replica Sets ("CSRS").</li>
</ul>
<h3 id="non-goals"><a class="header" href="#non-goals">Non-Goals</a></h3>
<ul>
<li>Provide a global server-side configuration of max acceptable staleness (see <a href="#rejected-ideas">rejected ideas</a>).</li>
<li>Support small values for max staleness.</li>
<li>Make a consistency guarantee resembling readConcern "afterOpTime".</li>
<li>Specify how maxStalenessSeconds interacts with readConcern "afterOpTime" in drivers (distinct from the goal for
routers and shards).</li>
<li>Compensate for the duration of server checks in staleness estimations.</li>
</ul>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p>"maxStalenessSeconds" is a new read preference option, with a positive integer value. It MUST be configurable similar to
other read preference options like "readPreference" and "tag_sets". Clients MUST also recognize it in the connection
string:</p>
<pre><code>mongodb://host/?readPreference=secondary&amp;maxStalenessSeconds=120
</code></pre>
<p>Clients MUST consider "maxStalenessSeconds=-1" in the connection string to mean "no maximum staleness".</p>
<p>A connection string combining a positive maxStalenessSeconds with read preference mode "primary" MUST be considered
invalid; this includes connection strings with no explicit read preference mode.</p>
<p>By default there is no maximum staleness.</p>
<p>A driver connected to a replica set requires that maxStalenessSeconds be absent, or be at least
smallestMaxStalenessSeconds (90 seconds) and at least heartbeatFrequencyMS + idleWritePeriodMS. The exact mechanism for
enforcement is defined in the Server Selection Spec.</p>
<p>Besides configuring maxStalenessSeconds in the connection string, the API for configuring it in code is not specified;
drivers are free to use None, null, -1, or other representations of "no value" to represent "no max staleness".</p>
<h3 id="replica-sets"><a class="header" href="#replica-sets">Replica Sets</a></h3>
<p>Replica set primaries and secondaries implement the following features to support maxStalenessSeconds.</p>
<h4 id="idlewriteperiodms"><a class="header" href="#idlewriteperiodms">idleWritePeriodMS</a></h4>
<p>An idle primary writes a no-op to the oplog every 10 seconds to refresh secondaries' lastWriteDate values (see
SERVER-23892 and <a href="#primary-must-write-periodic-no-ops">primary must write periodic no-ops</a>). This spec refers to this
period as <code>idleWritePeriodMS</code> with constant value 10,000.</p>
<h4 id="lastwrite"><a class="header" href="#lastwrite">lastWrite</a></h4>
<p>A primary's or secondary's hello response contains a "lastWrite" subdocument with these fields (SERVER-8858):</p>
<ul>
<li>lastWriteDate: a BSON UTC datetime, the wall-clock time of the <strong>primary</strong> when it most recently recorded a write to
the oplog.</li>
<li>opTime: an opaque value representing the position in the oplog of the most recently seen write. Needed for sharding,
not used for the maxStalenessSeconds read preference option.</li>
</ul>
<h3 id="wire-version"><a class="header" href="#wire-version">Wire Version</a></h3>
<p>The maxWireVersion MUST be incremented to 5 to indicate that the server includes maxStalenessSeconds features
(SERVER-23893).</p>
<h3 id="client"><a class="header" href="#client">Client</a></h3>
<p>A client (driver or mongos) MUST estimate the staleness of each secondary, based on lastWriteDate values provided in
server hello responses, and select for reads only those secondaries whose estimated staleness is less than or equal to
maxStalenessSeconds.</p>
<p>If any server's maxWireVersion is less than 5 and maxStalenessSeconds is a positive number, every attempt at server
selection throws an error.</p>
<p>When there is a known primary, a secondary S's staleness is estimated with this formula:</p>
<pre><code>(S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate) + heartbeatFrequencyMS
</code></pre>
<p>Where "P" and "S" are the primary's and secondary's ServerDescriptions. All datetimes are in milliseconds. The staleness
estimate could be temporarily negative.</p>
<p>When there is no known primary, a secondary S's staleness is estimated with this formula:</p>
<pre><code>SMax.lastWriteDate - S.lastWriteDate + heartbeatFrequencyMS
</code></pre>
<p>Where "SMax" is the secondary with the greatest lastWriteDate.</p>
<h4 id="explanation-of-staleness-estimate-with-primary"><a class="header" href="#explanation-of-staleness-estimate-with-primary">Explanation of Staleness Estimate With Primary</a></h4>
<ol>
<li>When the client checks the primary, it gets the delta between the primary's lastWriteDate and the client clock. Call
this "Client_to_Primary".</li>
<li>When the client checks a secondary, it gets the delta between the secondary's lastWriteDate and the client clock.
Call this "Client_to_Secondary".</li>
<li>The difference of these two is an estimate of the delta between the primary's and secondary's lastWriteDate.</li>
</ol>
<p>Thus:</p>
<pre><code>staleness = Client_to_Secondary - Client_to_Primary
= (S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate)
</code></pre>
<p>Finally, add heartbeatFrequencyMS:</p>
<pre><code>(S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate) + heartbeatFrequencyMS
</code></pre>
<p>This adjusts for the pessimistic assumption that S stops replicating right after S.lastUpdateTime, so it will be
heartbeatFrequencyMS <em>more</em> stale by the time it is checked again. This means S must be fresh enough at S.lastUpdateTime
to be eligible for reads from now until the next check, even if it stops replicating.</p>
<p>See the Server Discovery and Monitoring Spec and Server Selection Spec for details of client implementation.</p>
<h3 id="routers-and-shards"><a class="header" href="#routers-and-shards">Routers and shards</a></h3>
<p>Background: Shard servers and mongos servers in a sharded cluster with CSRS use readConcern "afterOptime" for
consistency guarantees when querying the shard config.</p>
<p>Besides tracking lastWriteDate, routers and shards additionally track the opTime of CSRS members if they have
maxWireVersion 5 or greater. (See Server Discovery and Monitoring Spec for details.)</p>
<p>When a router or shard selects a CSRS member to read from with readConcern like:</p>
<pre><code>readConcern: { afterOpTime: OPTIME }
</code></pre>
<p>... then it follows this selection logic:</p>
<ol>
<li>Make a list of known CSRS data members.</li>
<li>Filter out those whose last known opTime is older than OPTIME.</li>
<li>If no servers remain, select the primary.</li>
<li>Otherwise, select randomly one of the CSRS members whose roundTripTime is within localThresholdMS of the member with
the fastest roundTripTime.</li>
</ol>
<p>Step 4 is the standard localThresholdMS logic from the Server Selection Spec.</p>
<p>This algorithm helps routers and shards select a secondary that is likely to satisfy readConcern "afterOpTime" without
blocking.</p>
<p>This feature is only for routers and shards, not drivers. See <a href="#future-work">Future Work</a>.</p>
<h2 id="reference-implementation"><a class="header" href="#reference-implementation">Reference Implementation</a></h2>
<p>The C Driver (CDRIVER-1363) and Perl Driver (PERL-626).</p>
<h2 id="estimating-staleness-example-with-a-primary-and-continuous-writes"><a class="header" href="#estimating-staleness-example-with-a-primary-and-continuous-writes">Estimating Staleness: Example With a Primary and Continuous Writes</a></h2>
<p>Consider a primary P and a secondary S, and a client with heartbeatFrequencyMS set to 10 seconds. Say that the primary's
clock is 50 seconds skewed ahead of the client's.</p>
<p>The client checks P and S at time 60 (meaning 60 seconds past midnight) by the client's clock. The primary reports its
lastWriteDate is 10.</p>
<p>Then, S reports its lastWriteDate is 0. The client estimates S's staleness as:</p>
<pre><code>(S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate) + heartbeatFrequencyMS
= (60 - 0) - (60 - 10) + 10
= 20 seconds
</code></pre>
<p>(Values converted from milliseconds to seconds for the sake of discussion.)</p>
<p>Note that the secondary appears only 10 seconds stale at this moment, but the client adds heartbeatFrequencyMS,
pessimistically assuming that the secondary will not replicate at all between now and the next check. If the current
staleness plus heartbeatFrequencyMS is still less than maxStalenessSeconds, then we can safely read from the secondary
from now until the next check.</p>
<p>The client re-checks P and S 10 seconds later, at time 70 by the client's clock. S responds first with a lastWriteDate
of 5: it has fallen 5 seconds further behind. The client updates S's lastWriteDate and lastUpdateTime. The client now
estimates S's staleness as:</p>
<pre><code>(S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate) + heartbeatFrequencyMS
= (70 - 5) - (60 - 10) + 10
= 25 seconds
</code></pre>
<p>Say that P's response arrives 10 seconds later, at client time 80, and reports its lastWriteDate is 30. S's staleness is
still 25 seconds:</p>
<pre><code>(S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate) + heartbeatFrequencyMS
= (70 - 5) - (80 - 30) + 10
= 25 seconds
</code></pre>
<p>The same story as a table:</p>
<div class="table-wrapper"><table><thead><tr><th>Client clock</th><th>Primary clock</th><th>Event</th><th>S.lastUpdateTime</th><th>S.lastWriteDate</th><th>P.lastUpdateTime</th><th>P.lastWriteDate</th><th>S staleness</th></tr></thead><tbody>
<tr><td>60</td><td>10</td><td>P and S respond</td><td>60</td><td>0</td><td>60</td><td>10</td><td>20 seconds</td></tr>
<tr><td>70</td><td>20</td><td>S responds</td><td>70</td><td>5</td><td>60</td><td>10</td><td>25 seconds</td></tr>
<tr><td>80</td><td>30</td><td>P responds</td><td>70</td><td>5</td><td>80</td><td>30</td><td>25 seconds</td></tr>
</tbody></table>
</div>
<h2 id="estimating-staleness-example-with-no-primary"><a class="header" href="#estimating-staleness-example-with-no-primary">Estimating Staleness: Example With No Primary</a></h2>
<p>Consider a replica set with secondaries S1 and S2, and no primary. S2 lags 15 seconds <em>farther</em> behind S1 and has not
yet caught up. The client has heartbeatFrequencyMS set to 10 seconds.</p>
<p>When the client checks the two secondaries, S1's lastWriteDate is 20 and S2's lastWriteDate is 5.</p>
<p>Because S1 is the secondary with the maximum lastWriteDate, "SMax", its staleness estimate equals heartbeatFrequencyMS:</p>
<blockquote>
<p>SMax.lastWriteDate - S.lastWriteDate + heartbeatFrequencyMS = 20 - 20 + 10 = 10</p>
</blockquote>
<p>(Since max staleness must be at least heartbeatFrequencyMS + idleWritePeriodMS, S1 is eligible for reads no matter
what.)</p>
<p>S2's staleness estimate is:</p>
<pre><code>SMax.lastWriteDate - S.lastWriteDate + heartbeatFrequencyMS
= 20 - 5 + 10
= 25
</code></pre>
<h2 id="estimating-staleness-example-of-worst-case-accuracy-with-idle-replica-set"><a class="header" href="#estimating-staleness-example-of-worst-case-accuracy-with-idle-replica-set">Estimating Staleness: Example of Worst-Case Accuracy With Idle Replica Set</a></h2>
<p>Consider a primary P and a secondary S, and a client with heartbeatFrequencyMS set to 500 ms. There is no clock skew.
(Previous examples show that skew has no effect.)</p>
<p>The primary has been idle for 10 seconds and writes a no-op to the oplog at time 50 (meaning 50 seconds past midnight),
and again at time 60.</p>
<p>Before the secondary can replicate the no-op at time 60, the client checks both servers. The primary reports its
lastWriteDate is 60, the secondary reports 50.</p>
<p>The client estimates S's staleness as:</p>
<pre><code>(S.lastUpdateTime - S.lastWriteDate) - (P.lastUpdateTime - P.lastWriteDate) + heartbeatFrequencyMS
= (60 - 50) - (60 - 60) + 0.5
= 10.5
</code></pre>
<p>The same story as a table:</p>
<div class="table-wrapper"><table><thead><tr><th>Clock</th><th>Event</th><th>S.lastUpdateTime</th><th>S.lastWriteDate</th><th>P.lastUpdateTime</th><th>P.lastWriteDate</th><th>S staleness</th></tr></thead><tbody>
<tr><td>50</td><td>Idle write</td><td>50</td><td></td><td>50</td><td></td><td></td></tr>
<tr><td>60</td><td>Idle write begins</td><td>60</td><td></td><td>50</td><td></td><td></td></tr>
<tr><td>60</td><td>Client checks P and S</td><td>60</td><td>60</td><td>50</td><td>60</td><td>10.5</td></tr>
<tr><td>60</td><td>Idle write completes</td><td>60</td><td></td><td>60</td><td></td><td></td></tr>
</tbody></table>
</div>
<p>In this scenario the actual secondary lag is between 0 and 10 seconds. But the staleness estimate can be as large as:</p>
<pre><code>staleness = idleWritePeriodMS + heartbeatFrequencyMS
</code></pre>
<p>To ensure the secondary is always eligible for reads in an idle replica set, we require:</p>
<pre><code>maxStalenessSeconds * 1000 &gt;= heartbeatFrequencyMS + idleWritePeriodMS
</code></pre>
<h2 id="supplemental"><a class="header" href="#supplemental">Supplemental</a></h2>
<p>Python scripts in this document's source directory:</p>
<ul>
<li><code>test_max_staleness_spo.py</code>: Uses <code>scipy.optimize</code> to determine worst-case accuracy of the staleness estimate in an
idle replica set.</li>
<li><code>test_staleness_estimate.py</code>: Tests whether a client would correctly select a secondary from an idle replica set,
given a random distribution of values for maxStalenessSeconds, heartbeatFrequencyMS, lastWriteDate, and
lastUpdateTime.</li>
</ul>
<h2 id="test-plan"><a class="header" href="#test-plan">Test Plan</a></h2>
<p>See <code>max-staleness-tests.md</code>, and the YAML and JSON tests in the tests directory.</p>
<h2 id="design-rationale"><a class="header" href="#design-rationale">Design Rationale</a></h2>
<h3 id="specify-max-staleness-in-seconds"><a class="header" href="#specify-max-staleness-in-seconds">Specify max staleness in seconds</a></h3>
<p>Other driver options that are timespans are in milliseconds, for example serverSelectionTimeoutMS. The max staleness
option is specified in seconds, however, to make it obvious to users that clients can only enforce large, imprecise max
staleness values.</p>
<h3 id="maxstalenessseconds-is-part-of-read-preferences"><a class="header" href="#maxstalenessseconds-is-part-of-read-preferences">maxStalenessSeconds is part of Read Preferences</a></h3>
<p>maxStalenessSeconds MAY be configurable at the client, database, and collection level, and per operation, the same as
other read preference fields are, because users expressed that their tolerance for stale reads varies per operation.</p>
<h3 id="primary-must-write-periodic-no-ops"><a class="header" href="#primary-must-write-periodic-no-ops">Primary must write periodic no-ops</a></h3>
<p>Consider a scenario in which the primary does <em>not</em>:</p>
<ol>
<li>There are no writes for an hour.</li>
<li>A client performs a heavy read-only workload with read preference mode "nearest" and maxStalenessSeconds of 90
seconds.</li>
<li>The primary receives a write.</li>
<li>In the brief time before any secondary replicates the write, the client re-checks all servers.</li>
<li>Since the primary's lastWriteDate is an hour ahead of all secondaries', the client only queries the primary.</li>
<li>After heartbeatFrequencyMS, the client re-checks all servers and finds that the secondaries aren't lagging after all,
and resumes querying them.</li>
</ol>
<p>This apparent "replication lag spike" is just a measurement error, but it causes exactly the behavior the user wanted to
avoid: a small replication lag makes the client route all queries from the secondaries to the primary.</p>
<p>Therefore an idle primary must execute a no-op every 10 seconds (idleWritePeriodMS) to keep secondaries' lastWriteDate
values close to the primary's clock. The no-op also keeps opTimes close to the primary's, which helps mongos choose an
up-to-date secondary to read from in a CSRS.</p>
<p>Monitoring software like MongoDB Cloud Manager that charts replication lag will also benefit when spurious lag spikes
are solved.</p>
<p>See
<a href="#estimating-staleness-example-of-worst-case-accuracy-with-idle-replica-set">Estimating Staleness: Example of Worst-Case Accuracy With Idle Replica Set</a>.
and <a href="https://jira.mongodb.org/browse/SERVER-23892">SERVER-23892</a>.</p>
<h3 id="smallest-allowed-value-for-maxstalenessseconds"><a class="header" href="#smallest-allowed-value-for-maxstalenessseconds">Smallest allowed value for maxStalenessSeconds</a></h3>
<p>If maxStalenessSeconds is a positive number, it must be at least smallestMaxStalenessSeconds (90 seconds) and at least
heartbeatFrequencyMS + idleWritePeriodMS. The exact mechanism for enforcement is defined in the Server Selection Spec.</p>
<p>The justification for heartbeatFrequencyMS + idleWritePeriodMS is technical: If maxStalenessSeconds is set to exactly
heartbeatFrequencyMS (converted to seconds), then so long as a secondary lags even a millisecond it is ineligible.
Despite the user's read preference mode, the client will always read from the primary.</p>
<p>This is an example of "inadvertent primary read preference": a maxStalenessSeconds setting so small it forces all reads
to the primary regardless of actual replication lag. We want to prohibit this effect (see <a href="#goals">goals</a>).</p>
<p>We also want to ensure that a secondary in an idle replica set is always considered eligible for reads with
maxStalenessSeconds. See
<a href="#estimating-staleness-example-of-worst-case-accuracy-with-idle-replica-set">Estimating Staleness: Example of Worst-Case Accuracy With Idle Replica Set</a>.</p>
<p>Requiring maxStalenessSeconds to be at least 90 seconds is a design choice. If the only requirement were that
maxStalenessSeconds be at least heartbeatFrequencyMS + idleWritePeriodMS, then the smallest value would be 20 seconds
for multi-threaded drivers (10 second idleWritePeriodMS plus multi-threaded drivers' default 10 second
heartbeatFrequencyMS), 70 seconds for single-threaded drivers (whose default heartbeatFrequencyMS is 60 seconds), and 40
seconds for mongos (whose replica set monitor checks servers every 30 seconds).</p>
<p>The smallest configurable value for heartbeatFrequencyMS is 0.5 seconds, so maxStalenessSeconds could be as small as
10.5 when using a driver connected to a replica set, but mongos provides no such flexibility.</p>
<p>Therefore, this spec <em>also</em> requires that maxStalenessSeconds is at least 90:</p>
<ul>
<li>To provide a minimum for all languages and topologies that is easy to document and explain</li>
<li>To avoid application breakage when moving from replica set to sharded cluster, or when using the same URI with
different drivers</li>
<li>To emphasize that maxStalenessSeconds is a low-precision heuristic</li>
<li>To avoid the arbitrary-seeming minimum of 70 seconds imposed by single-threaded drivers</li>
</ul>
<h3 id="all-servers-must-have-wire-version-5-to-support-maxstalenessseconds"><a class="header" href="#all-servers-must-have-wire-version-5-to-support-maxstalenessseconds">All servers must have wire version 5 to support maxStalenessSeconds</a></h3>
<p>Clients with minWireVersion &lt; 5 MUST throw an error if maxStalenessSeconds is set, and any available server in the
topology has maxWireVersion less than 5.</p>
<p>An available server is defined in the <a href="../server-selection/server-selection.html#terms">Server Selection</a> specification.</p>
<p>Servers began reporting lastWriteDate in wire protocol version 5, and clients require some or all servers' lastWriteDate
in order to estimate any servers' staleness. The exact requirements of the formula vary according to TopologyType, so
this spec makes a simple ruling: if any server is running an outdated version, maxStalenessSeconds cannot be supported.</p>
<h3 id="rejected-ideas"><a class="header" href="#rejected-ideas">Rejected ideas</a></h3>
<h4 id="add-all-secondaries-optimes-to-primarys-hello-response"><a class="header" href="#add-all-secondaries-optimes-to-primarys-hello-response">Add all secondaries' opTimes to primary's hello response</a></h4>
<p>Not needed; each secondary's self-report of its opTime is just as good as the primary's.</p>
<h4 id="use-optimes-from-command-responses-besides-hello"><a class="header" href="#use-optimes-from-command-responses-besides-hello">Use opTimes from command responses besides hello</a></h4>
<p>An idea was to add opTime to command responses that don't already include it (e.g., "find"), and use these opTimes to
update ServerDescriptions more frequently than the periodic hello calls.</p>
<p>But while a server is not being used (e.g., while it is too stale, or while it does not match some other part of the
Read Preference), only its periodic hello responses can update its opTime. Therefore, heartbeatFrequencyMS sets a lower
bound on maxStalenessSeconds, so there is no benefit in recording each server's opTime more frequently. On the other
hand there would be costs: effort adding opTime to all command responses, lock contention getting the opTime on the
server and recording it on the client, complexity in the spec and the client code.</p>
<h4 id="use-current-time-in-staleness-estimate"><a class="header" href="#use-current-time-in-staleness-estimate">Use current time in staleness estimate</a></h4>
<p>A proposed staleness formula estimated the secondary's worst possible staleness:</p>
<pre><code>P.lastWriteDate + (now - P.lastUpdateTime) - S.lastWriteDate
</code></pre>
<p>In this proposed formula, the place occupied by "S.lastUpdateTime" in the actual formula is replaced with "now", at the
moment in the server selection process when staleness is being estimated.</p>
<p>This formula attempted a worst-case estimate right now: it assumed the primary kept writing after the client checked it,
and that the secondary replicated nothing since the client last checked the secondary. The formula was rejected because
it would slosh load to and from the secondary during the interval between checks.</p>
<p>For example: Say heartbeatFrequencyMS is 10 seconds and maxStalenessSeconds is set to 25 seconds, and immediately after
a secondary is checked its staleness is estimated at 20 seconds. It is eligible for reads until 5 seconds after the
check, then it becomes ineligible, causing all queries to be directed to the primary until the next check, 5 seconds
later.</p>
<h4 id="server-side-configuration"><a class="header" href="#server-side-configuration">Server-side Configuration</a></h4>
<p>We considered a deployment-wide "max staleness" setting that servers communicate to clients in hello, e.g., "120 seconds
is the max staleness." The read preference config is simplified: "maxStalenessSeconds" is gone, instead we have
"staleOk: true" (the default?) and "staleOk: false".</p>
<p>Based on Customer Advisory Board feedback, configuring staleness per-operation on the client side is more useful. We
should merely avoid closing the door on a future server-side configuration feature.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Complaints about stale reads, and proposed solutions:</p>
<ul>
<li><a href="https://jira.mongodb.org/browse/SERVER-3346">SERVER-3346</a></li>
<li><a href="https://jira.mongodb.org/browse/SERVER-4935">SERVER-4935</a></li>
<li><a href="https://jira.mongodb.org/browse/SERVER-4936">SERVER-4936</a></li>
<li><a href="https://jira.mongodb.org/browse/SERVER-8476">SERVER-8476</a></li>
<li><a href="https://jira.mongodb.org/browse/SERVER-12861">SERVER-12861</a></li>
</ul>
<h2 id="future-work"><a class="header" href="#future-work">Future Work</a></h2>
<h3 id="future-feature-to-support-readconcern-afteroptime"><a class="header" href="#future-feature-to-support-readconcern-afteroptime">Future feature to support readConcern "afterOpTime"</a></h3>
<p>If a future spec allows applications to use readConcern "afterOptime", clients should prefer secondaries that have
already replicated to that opTime, so reads do not block. This is an extension of the mongos logic for CSRS to
applications.</p>
<h3 id="future-feature-to-support-server-side-configuration"><a class="header" href="#future-feature-to-support-server-side-configuration">Future feature to support server-side configuration</a></h3>
<p>For this spec, we chose to control maxStalenessSeconds in client code. A future spec could allow database administrators
to configure from the server side how much replication lag makes a secondary too stale to read from. (See
<a href="#server-side-configuration">Server-side Configuration</a> above.) This could be implemented atop the current feature: if a
server communicates is staleness configuration in its hello response like:</p>
<pre><code>{ hello: true, maxStalenessSeconds: 30 }
</code></pre>
<p>... then a future client can use the value from the server as its default maxStalenessSeconds when there is no
client-side setting.</p>
<h2 id="changelog"><a class="header" href="#changelog">Changelog</a></h2>
<ul>
<li>
<p>2024-08-09: Updated wire versions in tests to 4.0+.</p>
</li>
<li>
<p>2024-04-30: Migrated from reStructuredText to Markdown.</p>
</li>
<li>
<p>2022-10-05: Remove spec front matter and revise changelog.</p>
</li>
<li>
<p>2021-09-08: Updated tests to support driver removal of support for server versions older than 3.6.</p>
</li>
<li>
<p>2021-09-03: Clarify that wire version check only applies to available servers.</p>
</li>
<li>
<p>2021-04-06: Updated to use hello command.</p>
</li>
<li>
<p>2016-09-29: Specify "no max staleness" in the URI with "maxStalenessMS=-1" instead of "maxStalenessMS=0".</p>
</li>
<li>
<p>2016-10-24: Rename option from "maxStalenessMS" to "maxStalenessSeconds".</p>
</li>
<li>
<p>2016-10-25: Change minimum maxStalenessSeconds value from 2 * heartbeatFrequencyMS to heartbeatFrequencyMS +
idleWritePeriodMS (with proper conversions of course).</p>
</li>
<li>
<p>2016-11-21: Revert changes that would allow idleWritePeriodMS to change in the future, require maxStalenessSeconds to
be at least 90.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../server-selection/server-selection.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../retryable-reads/retryable-reads.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../server-selection/server-selection.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../retryable-reads/retryable-reads.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
