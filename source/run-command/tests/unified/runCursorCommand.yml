description: runCursorCommand

schemaVersion: '1.9'

createEntities:
  - client:
      id: &failPointClient failPointClient
      useMultipleMongoses: false
  - client:
      id: &commandClient commandClient
      useMultipleMongoses: false
      observeEvents: [commandStartedEvent, commandSucceededEvent]
  - client:
      id: &client client
      useMultipleMongoses: false
      observeEvents: [commandStartedEvent]
  - session:
      id: &session session
      client: *client
  - database: # For tests that need success event assertions
      id: &commandDb commandDb
      client: *commandClient
      databaseName: *commandDb
  - database:
      id: &db db
      client: *client
      databaseName: *db
  - collection:
      id: &collection collection
      database: *db
      collectionName: *collection

initialData:
  - collectionName: collection
    databaseName: *db
    documents: &documents
      - { _id: 1, x: 11 }
      - { _id: 2, x: 22 }
      - { _id: 3, x: 33 }
      - { _id: 4, x: 44 }
      - { _id: 5, x: 55 }

tests:
  # This is what this API was invented to do.
  - description: successfully executes checkMetadataConsistency cursor creating command
    runOnRequirements:
      - minServerVersion: '7.0'
        topologies: [sharded]
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: checkMetadataConsistency
          command: { checkMetadataConsistency: 1 }
        expectResult: []
    expectEvents:
      - client: *client
        eventType: command
        events:
          - commandStartedEvent:
              command:
                checkMetadataConsistency: 1
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: checkMetadataConsistency

  - description: errors if the command response is not a cursor
    operations:
      - name: createRunCursorCommand
        object: *db
        arguments:
          commandName: ping
          command: { ping: 1 }
        expectError:
          isClientError: true


  # Driver Sessions
  - description: creates an implicit session that is reused across getMores
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          command: { find: *collection, filter: {}, batchSize: 2 }
        expectResult: *documents
      - name: assertSameLsidOnLastTwoCommands
        object: testRunner
        arguments:
          client: *client
    expectEvents:
      - client: *client
        eventType: command
        events:
          - commandStartedEvent:
              command:
                find: *collection
                filter: {}
                batchSize: 2
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: find
          - commandStartedEvent:
              command:
                getMore: { $$type: long }
                collection: *collection
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: getMore

  - description: accepts an explicit session that is reused across getMores
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          session: *session
          command: { find: *collection, filter: {}, batchSize: 2 }
        expectResult: *documents
      - name: assertSameLsidOnLastTwoCommands
        object: testRunner
        arguments:
          client: *client
    expectEvents:
      - client: *client
        eventType: command
        events:
          - commandStartedEvent:
              command:
                find: *collection
                filter: {}
                batchSize: 2
                $db: *db
                lsid: { $$sessionLsid: *session }
              commandName: find
          - commandStartedEvent:
              command:
                getMore: { $$type: long }
                collection: *collection
                $db: *db
                lsid: { $$sessionLsid: *session }
              commandName: getMore

  # Load Balancers
  - description: returns pinned connections to the pool when the cursor is exhausted
    runOnRequirements:
      - topologies: [ load-balanced ]
    operations:
      - name: createRunCursorCommand
        object: *db
        arguments:
          commandName: find
          batchSize: 2
          command: { find: *collection, filter: {}, batchSize: 2 }
        saveResultAsEntity: &cursor cursor
      - name: assertNumberConnectionsCheckedOut
        object: testRunner
        arguments:
          client: *client
          connections: 1
      - name: iterateUntilDocumentOrError
        object: *cursor
        expectResult: { _id: 1, x: 11 }
      - name: iterateUntilDocumentOrError
        object: *cursor
        expectResult: { _id: 2, x: 22 }
      - name: iterateUntilDocumentOrError
        object: *cursor
        expectResult: { _id: 3, x: 33 }
      - name: iterateUntilDocumentOrError
        object: *cursor
        expectResult: { _id: 4, x: 44 }
      - name: iterateUntilDocumentOrError
        object: *cursor
        expectResult: { _id: 5, x: 55 }
      - name: assertNumberConnectionsCheckedOut
        object: testRunner
        arguments:
          client: *client
          connections: 0
    expectEvents:
      - client: *client
        eventType: command
        events:
          - commandStartedEvent:
              command:
                find: *collection
                filter: {}
                batchSize: 2
                $db: *db
                lsid: { $$sessionLsid: *session }
              commandName: find
          - commandStartedEvent:
              command:
                getMore: { $$type: long }
                collection: *collection
                $db: *db
                lsid: { $$sessionLsid: *session }
              commandName: getMore
      - client: *client
        eventType: cmap
        events:
          - connectionReadyEvent: {}
          - connectionCheckedOutEvent: {}
          - connectionCheckedInEvent: {}

  - description: returns pinned connections to the pool when the cursor is closed
    runOnRequirements:
      - topologies: [ load-balanced ]
    operations:
      - name: createRunCursorCommand
        object: *db
        arguments:
          commandName: find
          command: { find: *collection, filter: {}, batchSize: 2 }
        saveResultAsEntity: *cursor
      - name: assertNumberConnectionsCheckedOut
        object: testRunner
        arguments:
          client: *client
          connections: 1
      - name: close
        object: *cursor
      - name: assertNumberConnectionsCheckedOut
        object: testRunner
        arguments:
          client: *client
          connections: 0

  # Iterating the Cursor / Executing GetMores
  - description: supports configuring getMore batchSize
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          batchSize: 5
          command: { find: *collection, filter: {}, batchSize: 1 }
        expectResult: *documents
    expectEvents:
      - client: *client
        eventType: command
        events:
          - commandStartedEvent:
              command:
                find: *collection
                filter: {}
                batchSize: 1
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: find
          - commandStartedEvent:
              command:
                getMore: { $$type: long }
                collection: *collection
                batchSize: 5
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: getMore

  - description: supports configuring getMore maxTimeMS
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          maxTimeMS: 300
          command: { find: *collection, filter: {}, maxTimeMS: 200, batchSize: 1 }
        expectError:
          # maxTimeMS can only be used with getMore for tailable, awaitData cursors
          isClientError: false
    expectEvents:
      - client: *client
        eventType: command
        ignoreExtraEvents: true
        events:
          - commandStartedEvent:
              command:
                find: *collection
                filter: {}
                maxTimeMS: 200
                batchSize: 1
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: find
          - commandStartedEvent:
              command:
                getMore: { $$type: long }
                collection: *collection
                $db: *db
                maxTimeMS: 300
                lsid: { id: { $$type: binData } }
              commandName: getMore

  - description: supports configuring getMore comment
    runOnRequirements:
      - minServerVersion: '4.5'
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          comment: &comment { hello: 'mongodb' }
          command: { find: *collection, filter: {}, batchSize: 1 }
        expectResult: *documents
    expectEvents:
      - client: *client
        eventType: command
        events:
          - commandStartedEvent:
              command:
                find: *collection
                filter: {}
                batchSize: 1
                comment: { $$exists: false }
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: find
          - commandStartedEvent:
              command:
                getMore: { $$type: long }
                collection: *collection
                comment: *comment
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: getMore

  # Tailable cursor
  - description: does not close the cursor when receiving an empty batch
    operations:
      - name: dropCollection
        object: *db
        arguments:
          collection: &cappedCollection cappedCollection
      - name: createCollection
        object: *db
        arguments:
          collection: *cappedCollection
          capped: true
          size: 4096
          max: 3
        saveResultAsEntity: *cappedCollection
      - name: insertMany
        object: *cappedCollection
        arguments:
          documents:
            - { _id: 1, x: 11 }
            - { _id: 2, x: 22 }
      - name: createRunCursorCommand
        object: *db
        arguments:
          cursorType: tailable
          commandName: find
          batchSize: 2
          command: { find: *cappedCollection, filter: {}, tailable: true }
        saveResultAsEntity: &cursor cursor
      - name: iterateOnce
        object: *cursor
      - name: iterateOnce
        object: *cursor
      - name: iterateOnce
        object: *cursor
      - name: close
        object: *cursor
    expectEvents:
      - client: *client
        eventType: command
        events:
          - commandStartedEvent:
              command:
                drop: *cappedCollection
              commandName: drop
          - commandStartedEvent:
              command:
                create: *cappedCollection
              commandName: create
          - commandStartedEvent:
              command:
                insert: *cappedCollection
              commandName: insert
          - commandStartedEvent:
              command:
                find: *cappedCollection
                filter: {}
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: find
          - commandStartedEvent:
              command:
                getMore: { $$type: long }
                collection: *cappedCollection
                $db: *db
                lsid: { id: { $$type: binData } }
              commandName: getMore
          - commandStartedEvent:
              command:
                killCursors: *cappedCollection
                cursors: [{ $$type: long }]
              commandName: killCursors

  # CSOT
  - description: errors if timeoutMode is set without timeoutMS
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          command: { find: *collection, filter: {} }
          timeoutMode: cursorLifetime
        expectError:
          isClientError: true

  - description: error if timeoutMode is cursor_lifetime and cursorType is tailableAwait
    operations:
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          command: { find: *collection, filter: {} }
          timeoutMode: cursorLifetime
          cursorType: tailableAwait
        expectError:
          isClientError: true

  - description: error if getMore maxTimeMS setting is greater than timeoutMS
    operations:
      - name: runCursorCommand
        object: *collection
        arguments:
          commandName: find
          command: { find: *collection, filter: {} }
          timeoutMS: 5
          maxTimeMS: 10
        expectError:
          isClientError: true

  - description: error if getMore maxTimeMS setting is equal to timeoutMS
    operations:
      - name: runCursorCommand
        object: *collection
        arguments:
          commandName: find
          command: { find: *collection, filter: {} }
          timeoutMS: 5
          maxTimeMS: 5
        expectError:
          isClientError: true


  # If timeoutMode is unset, it should default to CURSOR_LIFETIME and the time remaining after the find succeeds should be applied to the getMore
  - description: remaining timeoutMS applied to getMore if timeoutMode is unset
    operations:
      # Block find/getMore for 15ms.
      - name: failPoint
        object: testRunner
        arguments:
          client: *failPointClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 2 }
            data:
              failCommands: ["find", "getMore"]
              blockConnection: true
              blockTimeMS: 15
      # Run a find with timeoutMS=20 and batchSize=1 to force two batches, which will cause a find and a getMore to be sent.
      # Both will block for 15ms so together they will go over the timeout.
      - name: runCursorCommand
        object: *db
        arguments:
          commandName: find
          timeoutMS: 20
          command: { find: *collection, filter: {}, batchSize: 2 }
        expectError:
          isTimeoutError: true
    expectEvents:
      - client: *client
        events:
          - commandStartedEvent:
              commandName: find
              command:
                find: *collection
                maxTimeMS: { $$type: ["int", "long"] }
          - commandStartedEvent:
              commandName: getMore
              command:
                getMore: { $$type: ["int", "long"] }
                collection: *collection
                maxTimeMS: { $$exists: false }
