description: state change errors are correctly handled

schemaVersion: '1.3'

runOnRequirements:
  - loadBalanced: true

_yamlAnchors:
  observedEvents:
    - &observedEvents
      - connectionCreatedEvent
      - connectionReadyEvent
      - connectionCheckedOutEvent
      - connectionCheckOutFailedEvent
      - connectionCheckedInEvent
      - connectionClosedEvent
      - poolClearedEvent

createEntities:
  - client:
      id: &failPointClient failPointClient
      useMultipleMongoses: false
  - client:
      id: &singleClient singleClient
      useMultipleMongoses: false
      uriOptions:
        appname: &singleClientAppName lbSDAMErrorTestClient
        retryWrites: false
      observeEvents: *observedEvents
  - database:
      id: &singleDB singleDB
      client: *singleClient
      databaseName: &singleDBName singleDB
  - collection:
      id: &singleColl singleColl
      database: *singleDB
      collectionName: &singleCollName singleColl
  - client:
      id: &multiClient multiClient
      useMultipleMongoses: true
      uriOptions:
        retryWrites: false
      observeEvents: *observedEvents
  - database:
      id: &multiDB multiDB
      client: *multiClient
      databaseName: &multiDBName multiDB
  - collection:
      id: &multiColl multiColl
      database: *multiDB
      collectionName: &multiCollName multiColl

initialData:
  - collectionName: *singleCollName
    databaseName: *singleDBName
    documents: []
  - collectionName: *multiCollName
    databaseName: *multiDBName
    documents:
      - _id: 1
      - _id: 2
      - _id: 3

tests:
  - description: only connections for a specific serverId are closed when pools are cleared
    operations:
      # Create two cursors to force two connections.
      - name: createFindCursor
        object: *multiColl
        arguments:
          filter: {}
          batchSize: 2
        saveResultAsEntity: &cursor0 cursor0
      - name: createFindCursor
        object: *multiColl
        arguments:
          filter: {}
          batchSize: 2
        saveResultAsEntity: &cursor1 cursor1
      # Close both cursors to return the connections to the pool.
      - name: close
        object: *cursor0
      - name: close
        object: *cursor1
      # Fail an operation with a state change error.
      - name: failPoint
        object: testRunner
        arguments:
          client: *multiClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 1 }
            data:
              failCommands: [insert]
              errorCode: &errorCode 11600 # InterruptedAtShutdown
      - name: insertOne
        object: *multiColl
        arguments:
          document: { x: 1 }
        expectError:
          errorCode: *errorCode
      # Do another operation to ensure the relevant connection has been closed.
      - name: insertOne
        object: *multiColl
        arguments:
          document: { x: 1 }
    expectEvents:
      - client: *multiClient
        events:
          # Create cursors.
          - connectionCreatedEvent: {}
          - connectionReadyEvent: {}
          - connectionCheckedOutEvent: {}
          - connectionCreatedEvent: {}
          - connectionReadyEvent: {}
          - connectionCheckedOutEvent: {}
          # Close cursors.
          - connectionCheckedInEvent: {}
          - connectionCheckedInEvent: {}
          # Set failpoint.
          - connectionCheckedOutEvent: {}
          - connectionCheckedInEvent: {}
          # First insertOne.
          - connectionCheckedOutEvent: {}
          - poolClearedEvent: {}
          - connectionCheckedInEvent: {}
          - connectionClosedEvent:
              reason: stale
          # Second insertOne.
          - connectionCheckedOutEvent: {}
          - connectionCheckedInEvent: {}

  # This test uses singleClient to ensure that connection attempts are routed
  # to the same mongos on which the failpoint is set.
  - description: errors during the initial connection hello are ignore 
    skipReason: blocked on running against 4.9+ until SERVER-55211
    runOnRequirements:
      - minServerVersion: '4.9'
    operations:
      - name: failPoint
        object: testRunner
        arguments:
          client: *failPointClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 1 }
            data:
              failCommands: [isMaster]
              closeConnection: true
              appName: *singleClientAppName
      - name: insertOne
        object: *singleColl
        arguments:
          document: { x: 1 }
        expectError:
          isClientError: true
    expectEvents:
      - client: *singleClient
        events:
          - connectionCreatedEvent: {}
          - connectionClosedEvent:
              reason: error
          - connectionCheckOutFailedEvent:
              reason: connectionError

  - description: errors during authentication are processed
    runOnRequirements:
      - auth: true
    operations:
      - name: failPoint
        object: testRunner
        arguments:
          client: *failPointClient
          failPoint:
            configureFailPoint: failCommand
            mode: { times: 1 }
            data:
              failCommands: [saslContinue]
              closeConnection: true
              appName: *singleClientAppName
      - name: insertOne
        object: *singleColl
        arguments:
          document: { x: 1 }
        expectError:
          isClientError: true
    expectEvents:
      - client: *singleClient
        events:
          - connectionCreatedEvent: {}
          - poolClearedEvent: {}
          - connectionClosedEvent:
              reason: error
          - connectionCheckOutFailedEvent:
              reason: connectionError
