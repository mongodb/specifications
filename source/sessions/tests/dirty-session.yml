runOn:
  # Retryable writes requires a replica set or sharded cluster.
  - minServerVersion: "3.6"
    topology: ["replicaset", "sharded"]

database_name: &database_name "session-tests"
collection_name: &collection_name "test"

data:
  - {_id: 1}

tests:
  - description: Dirty session is discarded integration test

    clientOptions:
      retryWrites: true
      socketTimeoutMS: 1000

    operations:
      - name: insertOne
        object: collection
        arguments:
          document: {_id: 2}
        result:
          insertedId: 2
      # Simulate a slow/stalled operation using a sleep in $where. The
      # client should see a network timeout (caused by socketTimeoutMS) which
      # interrupts both the initial attempt and the retry attempt.
      - name: updateOne
        object: collection
        arguments:
          filter:
            $where: "function() { sleep(5000); return false; }"
          update:
            $inc: {x: 1}
        error: true
      # The second operation should not block on the first. If the driver
      # does not discard the previous dirty session, then this retryable write
      # will block on the server waiting for the previous retryable write to
      # complete and thus it will fail due to the socketTimeoutMS.
      - name: insertOne
        object: collection
        arguments:
          document: {_id: 3}
        result:
          insertedId: 3

    expectations:
      - command_started_event:
          command:
            insert: *collection_name
            documents:
              - {_id: 2}
            ordered: true
          command_name: insert
          database_name: *database_name
      - command_started_event:
          command:
            update: *collection_name
            updates:
              - q: {$where: "function() { sleep(5000); return false; }"}
                u: {$inc: {x: 1}}
                multi: false
                upsert: false
            ordered: true
          command_name: update
          database_name: *database_name
      - command_started_event:
          command:
            update: *collection_name
            updates:
              - q: {$where: "function() { sleep(5000); return false; }"}
                u: {$inc: {x: 1}}
                multi: false
                upsert: false
            ordered: true
          command_name: update
          database_name: *database_name
      - command_started_event:
          command:
            insert: *collection_name
            documents:
              - {_id: 3}
            ordered: true
          command_name: insert
          database_name: *database_name

    outcome:
      collection:
        data:
          - {_id: 1}
          - {_id: 2}
          - {_id: 3}
